WEBVTT

1
00:00:00.033 --> 00:00:06.706
So the ledger contains a record
of all Bitcoin transactions.

2
00:00:06.706 --> 00:00:11.057
So it's a memory system, and
in fact this equivalence between money and

3
00:00:11.057 --> 00:00:16.354
memory was proposed by the macro-economist
Narayana Kocherlakota back in 1998.

4
00:00:16.354 --> 00:00:20.451
And his point is that money and
memory are the same.

5
00:00:20.451 --> 00:00:21.907
If you had perfect memory,

6
00:00:21.907 --> 00:00:25.593
you could implement any system that
you could implement with money.

7
00:00:25.593 --> 00:00:29.803
So, along with the digital signature,
the accurate ledger is required for

8
00:00:29.803 --> 00:00:32.390
the existence of property
rights in Bitcoin.

9
00:00:32.390 --> 00:00:34.248
Now, credit card companies, banks, and

10
00:00:34.248 --> 00:00:36.425
other intermediaries
essentially are ledgers.

11
00:00:36.425 --> 00:00:39.598
And they enforce the accuracy of the
ledger and hence enable property rights.

12
00:00:39.598 --> 00:00:43.294
And it's in their interest to
enforce the accuracy of the ledger,

13
00:00:43.294 --> 00:00:45.081
but Bitcoin is decentralized.

14
00:00:45.081 --> 00:00:48.591
So who is the keeper of
this collective memory, and

15
00:00:48.591 --> 00:00:50.885
who ensures that it is accurate?

16
00:00:50.885 --> 00:00:55.295
So in his Bitcoin whitepaper,
Satoshi Nakamoto realizes the problem with

17
00:00:55.295 --> 00:00:58.802
previous decentralized ledgers and
proposes a solution.

18
00:00:58.802 --> 00:01:01.529
In previous attempts to decentralize,

19
00:01:01.529 --> 00:01:06.192
creators focused on making it
impossible to tamper with the ledger.

20
00:01:06.192 --> 00:01:08.599
Now this is really hard because
the ledger is decentralized,

21
00:01:08.599 --> 00:01:09.950
it's on everybody's computer.

22
00:01:09.950 --> 00:01:13.780
So how are you going to
make it tamper proof?

23
00:01:13.780 --> 00:01:18.721
What Satoshi realized is that it was
sufficient to have incentives not to

24
00:01:18.721 --> 00:01:20.428
tamper with the ledger.

25
00:01:20.428 --> 00:01:24.586
And it was potentially much
easier to create incentives not

26
00:01:24.586 --> 00:01:27.675
the tamper than to
forbid tampering per se.

27
00:01:27.675 --> 00:01:30.887
And I think this is a nice
example of how from the very

28
00:01:30.887 --> 00:01:35.548
beginning Bitcoin combined computer
science with economic reasoning.

29
00:01:35.548 --> 00:01:39.754
So how to dis-incentivize participants
from tampering with the ledger?

30
00:01:39.754 --> 00:01:41.040
Well, the answer is,

31
00:01:41.040 --> 00:01:44.712
we make it easy to detect that
the ledger had been tampered with.

32
00:01:44.712 --> 00:01:49.507
And thus any dishonest participant
would be dissuaded from even trying.

33
00:01:49.507 --> 00:01:52.681
So, not only would any
attempt be detected,

34
00:01:52.681 --> 00:01:55.361
there would actually be no attempts.

35
00:01:55.361 --> 00:01:57.530
Of course,
we wouldn't want to get complacent.

36
00:01:57.530 --> 00:02:02.377
The absence of attempts would not mean
that the detection system was unnecessary.

37
00:02:02.377 --> 00:02:07.310
So tampering with the ledger in Bitcoin
is what in economics we call a, quote,

38
00:02:07.310 --> 00:02:09.047
off the equilibrium path.

39
00:02:09.047 --> 00:02:13.141
Nobody's going to do it, but
we still need to design incentives, so

40
00:02:13.141 --> 00:02:17.388
that it remains off the equilibrium,
as in not equilibrium behavior.

41
00:02:17.388 --> 00:02:20.825
So let's consider an example
of how we make it observable

42
00:02:20.825 --> 00:02:23.268
that the ledger has been tampered with.

43
00:02:23.268 --> 00:02:26.689
So I'm going to write down
a very simple ledger, so

44
00:02:26.689 --> 00:02:31.235
let's say Maria creates a simple coin,
we'll call it MariaCoin.

45
00:02:31.235 --> 00:02:34.868
And Maria is just going
to have this one coin and

46
00:02:34.868 --> 00:02:37.950
she's going to use it for her friends.

47
00:02:37.950 --> 00:02:41.231
We aren't going to discuss why this
would be useful at the moment,

48
00:02:41.231 --> 00:02:42.762
let's just assume it exists.

49
00:02:42.762 --> 00:02:45.781
So Maria creates MariaCoin.

50
00:02:45.781 --> 00:02:48.196
Then Maria sells MariaCoin to Sophie,

51
00:02:48.196 --> 00:02:52.966
presumably Sophie gives Maria some money,
dollars perhaps, in exchange.

52
00:02:52.966 --> 00:02:57.677
Then Sophie turns around and
sells the MariaCoin to Geoff.

53
00:02:57.677 --> 00:03:01.214
So from this description,
it is clear that, at the end,

54
00:03:01.214 --> 00:03:04.105
Geoff is the rightful
owner of the MariaCoin.

55
00:03:04.105 --> 00:03:07.923
But here's the problem, what if Bob,
say, were to come in and

56
00:03:07.923 --> 00:03:10.166
attempt to change the second stage?

57
00:03:10.166 --> 00:03:13.265
What if that second item were,
say, erased and

58
00:03:13.265 --> 00:03:17.621
rewritten to read that Maria sells
MariaCoin to Bob, not Sophie?

59
00:03:17.621 --> 00:03:22.013
So that would invalidate Sophie's
ownership and Geoff's ownership,

60
00:03:22.013 --> 00:03:24.899
because Sophie had no
right to sell it to Geoff.

61
00:03:24.899 --> 00:03:29.499
So we do not want this to happen, so
not only do we need to detect tampering at

62
00:03:29.499 --> 00:03:33.019
the last stage, but
at the intermediate stages as well.

63
00:03:33.019 --> 00:03:37.066
So here's the solution,
we make the ledger recursive.

64
00:03:37.066 --> 00:03:41.770
So Maria creates a single MariaCoin,
the second stage,

65
00:03:41.770 --> 00:03:44.913
Mario sells the MariaCoin to Sophie.

66
00:03:44.913 --> 00:03:50.313
Now what I've done here is I've upended
the initials of the previous transactions,

67
00:03:50.313 --> 00:03:51.591
transaction MCSM.

68
00:03:51.591 --> 00:03:57.036
So think of that as kind of a digest
of the previous transaction.

69
00:03:57.036 --> 00:04:01.896
Now the third stage is Sophie
sells the MariaCoin to Geoff.

70
00:04:01.896 --> 00:04:07.633
So what I do now is I not only have
the digest from the previous stage,

71
00:04:07.633 --> 00:04:10.161
but the first digest as well.

72
00:04:10.161 --> 00:04:14.921
So MSMS is Maria sells
the MariaCoin to Sophie,

73
00:04:14.921 --> 00:04:19.919
and then you also have within that digest,
MCSM,

74
00:04:19.919 --> 00:04:23.494
Maria creates a single MariaCoin.

75
00:04:23.494 --> 00:04:27.352
And then finally we digest
the whole thing, we have SSMG,

76
00:04:27.352 --> 00:04:29.890
so if he sells the MariaCoin to Geoff.

77
00:04:29.890 --> 00:04:35.910
And then the other previous two entries
are also embedded in that last digest.

78
00:04:35.910 --> 00:04:39.689
So to summarize, alongside each entry,
I have put a digest,

79
00:04:39.689 --> 00:04:42.319
a kind of shorthand to the previous entry.

80
00:04:42.319 --> 00:04:46.247
In creating this shorthand,
I followed a simple algorithm,

81
00:04:46.247 --> 00:04:49.050
I used the first letter
of each of the words.

82
00:04:49.050 --> 00:04:53.415
Now in principle, we could use
this to detect tampering, right?

83
00:04:53.415 --> 00:04:57.596
Because what we could do is we could
check if the initials match the words in

84
00:04:57.596 --> 00:04:58.750
the previous step.

85
00:04:58.750 --> 00:05:01.307
So let's just see an example
of how this would work.

86
00:05:01.307 --> 00:05:05.000
Let's say Bob were to tamper with
the second item on the ledger.

87
00:05:05.000 --> 00:05:08.632
Instead of reading,
Maria sells the MariaCoin to Sophie,

88
00:05:08.632 --> 00:05:12.418
he tampers with it to read,
Maria sells the MariaCoin to Bob.

89
00:05:12.418 --> 00:05:16.460
Well, at that point,
the digest would not match,

90
00:05:16.460 --> 00:05:20.793
MSMS at the next stage would
not be the right initials.

91
00:05:20.793 --> 00:05:26.012
So you could detect the tampering
by comparing the second stage

92
00:05:26.012 --> 00:05:31.244
with the digest that appears at
the second and the third stage.

93
00:05:31.244 --> 00:05:33.604
Now of course,
if Bob were really determined,

94
00:05:33.604 --> 00:05:36.680
he could tamper with a digest
that appears in the third stage.

95
00:05:36.680 --> 00:05:43.732
He could tamper both with item two, having
it read, Maria sells the MariaCoin to Bob.

96
00:05:43.732 --> 00:05:51.041
And he could then take MSMS and
change it to the appropriate initials.

97
00:05:51.041 --> 00:05:56.437
However, then the overall digest would
not match the stage three message.

98
00:05:56.437 --> 00:06:00.624
So in order to truly tamper with
the ledger in a way that could not

99
00:06:00.624 --> 00:06:05.451
be detected, Bob would have to first
tamper with the entry at stage two.

100
00:06:05.451 --> 00:06:12.957
Then the digest at stage three,
then digest of the digest at stage four.

101
00:06:12.957 --> 00:06:18.506
Now in this example, this digest
technique is pretty easy to work around.

102
00:06:18.506 --> 00:06:22.887
All Bob would have to do would be to find
a friend whose name begins with an S.

103
00:06:22.887 --> 00:06:27.639
And he could then tamper with it and
give the money to his friend,

104
00:06:27.639 --> 00:06:31.075
but this really is the idea
that Bitcoin uses.

105
00:06:31.075 --> 00:06:36.372
But there's a crucial difference,
the digest that I've created here

106
00:06:36.372 --> 00:06:42.478
is created using cryptography, not, say,
just the first initial of the names.

107
00:06:42.478 --> 00:06:46.600
And what that means is it's virtually
impossible to change the transaction in

108
00:06:46.600 --> 00:06:48.919
such a way that it still
matches the digest.

109
00:06:48.919 --> 00:06:52.069
So to summarize,
along with the digital signature,

110
00:06:52.069 --> 00:06:56.969
a tamper-proof ledger is a key feature of
Bitcoin that enforces property rights.

111
00:06:56.969 --> 00:07:00.940
Now, how do you make a ledger
tamper-proof when it is distributed?

112
00:07:00.940 --> 00:07:04.748
Answer, you make sure any
attempts will be discovered.

113
00:07:04.748 --> 00:07:06.007
So how do you do that?

114
00:07:06.007 --> 00:07:08.688
By making the ledger recursive,

115
00:07:08.688 --> 00:07:13.388
every entry contains a little
copy of the previous entry.