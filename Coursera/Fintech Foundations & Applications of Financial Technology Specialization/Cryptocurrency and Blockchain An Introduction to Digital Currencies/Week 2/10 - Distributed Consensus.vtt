WEBVTT

1
00:00:01.850 --> 00:00:07.990
In the last lectures, I introduced
the digital signature and the blockchain.

2
00:00:07.990 --> 00:00:12.510
Together these form the beginnings of a
system of property rights that depend only

3
00:00:12.510 --> 00:00:16.320
on computer protocols not
on a sovereign authority.

4
00:00:16.320 --> 00:00:17.925
However, they are not sufficient.

5
00:00:17.925 --> 00:00:24.026
For a currency to be valid it must
avoid the double spend attack.

6
00:00:24.026 --> 00:00:28.873
So one solution that we discussed last
time is having authority rest with one

7
00:00:28.873 --> 00:00:31.460
entity, that's this James coin idea.

8
00:00:33.060 --> 00:00:36.635
However, the entire idea of
cryptocurrency is to avoid this type

9
00:00:36.635 --> 00:00:39.436
of centralization however
effective it might be.

10
00:00:41.525 --> 00:00:45.070
So what is distributed consensus?

11
00:00:45.070 --> 00:00:48.465
So first of all,
let's think about the Bitcoin network.

12
00:00:48.465 --> 00:00:51.967
All the Bitcoin network is,
is a bunch of nodes,

13
00:00:51.967 --> 00:00:56.934
just computers that run the reference
version of Bitcoin software.

14
00:00:56.934 --> 00:00:59.084
These nodes are independent.

15
00:00:59.084 --> 00:01:02.969
They are all connected through
potentially multiple steps,

16
00:01:02.969 --> 00:01:06.340
not necessarily directly to each other.

17
00:01:06.340 --> 00:01:10.721
It's a system that has no built-in central
authority, it's fully peer-to-peer.

18
00:01:10.721 --> 00:01:15.090
All of these nodes are equal
in principle to one another.

19
00:01:16.480 --> 00:01:21.213
Now, one goal is to create a protocol
that allows all nodes to agree, but

20
00:01:21.213 --> 00:01:22.620
is that sufficient?

21
00:01:22.620 --> 00:01:27.640
No it is not, because we want the nodes
to agree on something called the truth.

22
00:01:27.640 --> 00:01:32.510
We want them to agree on some
version of the right thing.

23
00:01:32.510 --> 00:01:35.649
Now, in creating a concept
of distributed consensus,

24
00:01:35.649 --> 00:01:39.672
we will assume that nodes can be honest,
or that they can be malicious.

25
00:01:39.672 --> 00:01:45.160
In other words, we do not require
honesty on the part of the nodes.

26
00:01:45.160 --> 00:01:48.863
So here's a definition of
a distributed consensus protocol.

27
00:01:48.863 --> 00:01:51.586
Consider a network of nodes
each receiving a value.

28
00:01:51.586 --> 00:01:54.290
Some are malicious, some honest.

29
00:01:54.290 --> 00:01:57.627
A distributed consensus protocol must
terminate with all honest nodes in

30
00:01:57.627 --> 00:01:58.768
agreement on the value.

31
00:01:58.768 --> 00:02:04.190
And that this value must have
been generated by an honest node.

32
00:02:04.190 --> 00:02:08.268
So with this definition we can see
how distributed consensus applies

33
00:02:08.268 --> 00:02:09.330
the blockchain.

34
00:02:10.860 --> 00:02:14.950
As with the blockchain itself
we will reason recursively.

35
00:02:14.950 --> 00:02:21.230
That is, we're going to assume that the
system starts off in distribute consensus.

36
00:02:21.230 --> 00:02:27.060
Namely all honest nodes are in agreement
on what the blockchain look like.

37
00:02:27.060 --> 00:02:31.311
So we have a set of transactions that
have occurred in the past that form

38
00:02:31.311 --> 00:02:35.720
the blockchain, all honest nodes
are in agreement on that blockchain.

39
00:02:35.720 --> 00:02:41.050
Now, assume a bunch of new transactions
come in and some might be contradictory.

40
00:02:41.050 --> 00:02:46.034
We want to end with a new block added
to the ledger consisting of valid

41
00:02:46.034 --> 00:02:51.730
transactions on which all nodes agree,
that's where we're trying to get.

42
00:02:51.730 --> 00:02:55.530
Now, if we could assume that
even one node were honest, and

43
00:02:55.530 --> 00:02:58.570
if we could assign that
node a stable identity,

44
00:02:58.570 --> 00:03:03.300
we could just write software to send
all transactions through that node.

45
00:03:03.300 --> 00:03:07.010
Then the transactions could be
verified by all the other nodes.

46
00:03:07.010 --> 00:03:10.160
This is like James coin
in the previous lecture.

47
00:03:10.160 --> 00:03:14.940
However, the Bitcoin protocol avoids
assuming that any one node is honest.

48
00:03:14.940 --> 00:03:17.043
And it goes a step further,

49
00:03:17.043 --> 00:03:21.620
it avoids assigning stable
identities to the nodes at all.

50
00:03:21.620 --> 00:03:25.000
So, clearly we cannot prefer
any node over any other node.

51
00:03:25.000 --> 00:03:29.450
So here is an idea, we use randomness.

52
00:03:29.450 --> 00:03:35.170
Randomness is going to be key to
getting to the distributed consensus.

53
00:03:35.170 --> 00:03:39.988
Now before going any further, I want to
review the concept of the hash pointer

54
00:03:39.988 --> 00:03:43.710
because it's so important for
what I'm going to say next.

55
00:03:43.710 --> 00:03:48.537
So remember that a hash pointer
to a block is two things really,

56
00:03:48.537 --> 00:03:53.636
the first is the output of the hash
function applied to that block,

57
00:03:53.636 --> 00:03:57.660
that's called the hash and
a pointer to that block.

58
00:03:57.660 --> 00:04:00.200
So remember what defines a blockchain.

59
00:04:00.200 --> 00:04:07.160
Each block in the blockchain includes
a hash pointer to the previous block.

60
00:04:07.160 --> 00:04:13.850
So I'm going to take a first pass at the
Bitcoin distribute consensus algorithm.

61
00:04:13.850 --> 00:04:17.025
So here's the steps, first of all new

62
00:04:17.025 --> 00:04:22.000
transactions are broadcast to
all the nodes in the system.

63
00:04:22.000 --> 00:04:27.480
Second, each node collects these
transactions into a block.

64
00:04:27.480 --> 00:04:35.010
Third, at a fixed interval a random node
gets to propose the block it's created.

65
00:04:35.010 --> 00:04:38.390
Now what does proposing
a block mean actually?

66
00:04:38.390 --> 00:04:43.340
Well, it means as I said in step two,
collecting the transactions into a block.

67
00:04:43.340 --> 00:04:46.448
But it also means something else,

68
00:04:46.448 --> 00:04:52.030
it also means including a hash
pointer to the previous block.

69
00:04:52.030 --> 00:04:56.700
Then finally, all nodes check the block
to make sure the transactions are valid.

70
00:04:56.700 --> 00:05:01.530
So now this algorithm is going to
repeat itself again and again.

71
00:05:01.530 --> 00:05:06.194
Now let's see how this algorithm
avoids some problems, for

72
00:05:06.194 --> 00:05:10.590
some obvious problems and
then the double spend attack.

73
00:05:10.590 --> 00:05:14.047
First of all, it's not possible to
spend Bitcoins not belonging to

74
00:05:14.047 --> 00:05:17.640
you according to this algorithm,
even though it's decentralized.

75
00:05:17.640 --> 00:05:22.060
Because your signature will not match
the valid signature on the coins.

76
00:05:22.060 --> 00:05:27.680
And it's not possible to deny service
to a certain user whom you don't like.

77
00:05:27.680 --> 00:05:30.714
So if you are a malicious node,
you can say well,

78
00:05:30.714 --> 00:05:35.080
I'm not going to include the transactions
of a whole group of people,

79
00:05:35.080 --> 00:05:38.782
say, that I don't want to do
any business with in my block.

80
00:05:38.782 --> 00:05:44.918
That's fine, all these people
out there just need to wait for

81
00:05:44.918 --> 00:05:48.460
an honest node to get their chance.

82
00:05:48.460 --> 00:05:51.757
So this also avoids some,
more subtle problems,

83
00:05:51.757 --> 00:05:56.240
like the double spend attack that
I introduced in the last lecture.

84
00:05:56.240 --> 00:05:59.420
So, lets review the double spend attack.

85
00:05:59.420 --> 00:06:01.380
Remember MariaCoin.

86
00:06:01.380 --> 00:06:06.090
Remember that Maria transferred the coin
to Sophie, that was a valid transaction.

87
00:06:06.090 --> 00:06:09.035
Sophie transfers the coin to Geoff, but

88
00:06:09.035 --> 00:06:13.110
she also creates a message to
transfer the coin to Mike.

89
00:06:13.110 --> 00:06:18.270
Now, how does this work in
the system I just outlined?

90
00:06:18.270 --> 00:06:23.075
So, Sophie transfer to Geoff is
broadcast to the network of nodes,

91
00:06:23.075 --> 00:06:27.730
and Sophie transfer to Mike is
broadcast to the network of nodes.

92
00:06:27.730 --> 00:06:30.267
Some notes will receive the transfer
to Geoff message first,

93
00:06:30.267 --> 00:06:32.520
some will receive the transfer
to Mike message first.

94
00:06:32.520 --> 00:06:36.727
Now it's usually the policy of honest
nodes to include in their block

95
00:06:36.727 --> 00:06:41.600
the message received first but that's
a norm, it doesn't have to be that way.

96
00:06:41.600 --> 00:06:45.213
Now, some nodes might actually
be a friend of Geoff or

97
00:06:45.213 --> 00:06:48.440
a friend of Mike and
those nodes will be biased.

98
00:06:48.440 --> 00:06:53.315
However, as long as the nodes are running
the reference software they will not be

99
00:06:53.315 --> 00:06:57.700
able to include both because that will
not be a chain of valid ownership.

100
00:06:57.700 --> 00:07:02.551
Now, it's possible that some node could be
completely off the reservation and try and

101
00:07:02.551 --> 00:07:03.615
include both, and

102
00:07:03.615 --> 00:07:07.620
that's the situation that I'm going
to deal within the next lecture.

103
00:07:07.620 --> 00:07:08.484
So for now,

104
00:07:08.484 --> 00:07:14.460
assume that the nodes are sufficiently
honest that they include one or the other.

105
00:07:14.460 --> 00:07:18.035
So now suppose that the randomization
algorithm chooses a no with

106
00:07:18.035 --> 00:07:20.180
the Geoff transaction in it's block.

107
00:07:20.180 --> 00:07:24.270
The block then gets added to
the chain with a Geoff transaction.

108
00:07:24.270 --> 00:07:28.253
Now suppose in the next round the random
algorithm chooses a node with the Mike

109
00:07:28.253 --> 00:07:29.670
transaction in the block.

110
00:07:30.980 --> 00:07:33.394
What we see is a fork in the chain,

111
00:07:33.394 --> 00:07:37.204
because those two transactions
are inconsistent.

112
00:07:37.204 --> 00:07:43.411
It's as if we have a long chain
with two prongs at the end.

113
00:07:43.411 --> 00:07:46.200
So now what happens at the next step?

114
00:07:46.200 --> 00:07:48.455
So another note is randomly chosen.

115
00:07:48.455 --> 00:07:51.430
That note has to pick
which block to accept.

116
00:07:51.430 --> 00:07:54.028
Now what does it mean to accept a block?

117
00:07:54.028 --> 00:07:58.570
It means that it includes a hash pointer
to the previous block in its block.

118
00:07:58.570 --> 00:08:02.614
So it's going to include a hash
pointer either to the Geoff block or

119
00:08:02.614 --> 00:08:06.310
the Mike block and
that's going to narrow to find the chain.

120
00:08:06.310 --> 00:08:08.590
So which will it pick?

121
00:08:08.590 --> 00:08:13.670
We don't know and what's more we don't
care because it can only pick one.

122
00:08:13.670 --> 00:08:17.720
This means that double
spend attack is avoided.

123
00:08:17.720 --> 00:08:23.060
So at that point one fork in
the chain is longer than the other.

124
00:08:23.060 --> 00:08:28.310
Now it is the policy of honest nodes
on Bitcoin to extend the longest fork.

125
00:08:28.310 --> 00:08:32.700
This is a norm of Bitcoin but
nothing in software requires it.

126
00:08:32.700 --> 00:08:36.397
So let's say that the block with
the Geoff transaction has been chosen in

127
00:08:36.397 --> 00:08:37.250
the last round.

128
00:08:37.250 --> 00:08:40.349
That is the block that
gets to be continued, and

129
00:08:40.349 --> 00:08:43.380
the other block,
the other fork is orphaned.

130
00:08:43.380 --> 00:08:50.200
Okay, so now we have a chain with two
prongs, one of them longer than the other.

131
00:08:50.200 --> 00:08:55.352
So if all nodes are honest they will
simply continue with the longest folk and

132
00:08:55.352 --> 00:08:57.620
the other folk will be orphaned.

133
00:08:57.620 --> 00:09:00.851
But what if Mike's friends
all get together and

134
00:09:00.851 --> 00:09:04.980
build on the orphaned folk
containing the transfer to Mike?

135
00:09:04.980 --> 00:09:09.190
Note that this would only require control
of the nodes proposing new blocks.

136
00:09:09.190 --> 00:09:13.853
And then, as long as a sufficient number
of the nodes were controlled the rest of

137
00:09:13.853 --> 00:09:18.670
the honest nodes would follow because it
is the policy to extend the longest fork.

138
00:09:18.670 --> 00:09:19.862
This is why it is so

139
00:09:19.862 --> 00:09:24.720
important that the choice of node be
random in this thought experiment.

140
00:09:24.720 --> 00:09:29.396
Because if the choice of node were
not random then any specific fork

141
00:09:29.396 --> 00:09:33.170
could be extended and
one might not reach agreement.

142
00:09:33.170 --> 00:09:37.121
Of course, it is impossible for
a random node to be chosen,

143
00:09:37.121 --> 00:09:42.110
so this is a conundrum actually this
is not a feasible thought experiment.

144
00:09:42.110 --> 00:09:45.820
And I will discuss the solution to
this conundrum in the next lecture.

145
00:09:45.820 --> 00:09:51.560
For now let's talk about a consequence
of this distributed consensus protocol.

146
00:09:51.560 --> 00:09:54.670
Let's return to our example
of the forking paths.

147
00:09:54.670 --> 00:10:00.680
Recall that once the blockchain forks we
do not know which fork will be continued.

148
00:10:00.680 --> 00:10:03.561
However, once the Geoff
fork has one confirmation,

149
00:10:03.561 --> 00:10:07.977
the policy of honest nodes extending the
longest fork suggests it is more likely to

150
00:10:07.977 --> 00:10:09.780
receive a second confirmation.

151
00:10:09.780 --> 00:10:15.850
And then it is still more likely to
receive a third confirmation, and so on.

152
00:10:15.850 --> 00:10:20.380
As a practical matter, once there
have been several confirmations,

153
00:10:20.380 --> 00:10:24.540
it is very likely that a long term
consensus is formed on a block.

154
00:10:24.540 --> 00:10:27.757
And if one is exchanging goods or
services for Bitcoin,

155
00:10:27.757 --> 00:10:32.150
one can wait until several confirmations
before completing the exchange.

156
00:10:32.150 --> 00:10:37.056
Interestingly though, as a theoretical
matter, one does not know with 100%

157
00:10:37.056 --> 00:10:41.050
certainty that any block becomes
part of the long term consensus.

158
00:10:41.050 --> 00:10:45.490
Because one could always
in principle extend a fork.

159
00:10:45.490 --> 00:10:48.019
There is always some probability,
however minute,

160
00:10:48.019 --> 00:10:50.218
that an orphaned fork
will be picked up again.

161
00:10:50.218 --> 00:10:51.433
So to summarize,

162
00:10:51.433 --> 00:10:57.030
in this lecture I took a fast pass to
Bitcoin's distributed consensus protocol.

163
00:10:57.030 --> 00:10:59.463
Transactions are broadcast to the network,

164
00:10:59.463 --> 00:11:01.960
nodes collect the transactions
into a block,

165
00:11:01.960 --> 00:11:06.390
nodes are chosen at random to propose a
block, we call this a thought experiment.

166
00:11:06.390 --> 00:11:09.914
And in subsequent rounds,
other nodes accept or reject that block,

167
00:11:09.914 --> 00:11:12.050
potentially by accepting other blocks.

168
00:11:12.050 --> 00:11:14.416
Disagreements become forks
in the blockchain, and

169
00:11:14.416 --> 00:11:16.090
short forks are usually abandoned.

170
00:11:16.090 --> 00:11:20.250
It is the policy of honest nodes
to extend the longest fork.

171
00:11:20.250 --> 00:11:25.720
Eventually the system reaches consensus on
one chain, with near certain probability.

172
00:11:25.720 --> 00:11:28.337
There is always some probability,
however minute,

173
00:11:28.337 --> 00:11:30.730
that an abandoned fork
could be picked up again.

174
00:11:30.730 --> 00:11:35.489
Thus, property rights in Bitcoin are
inherently probabilistic, yet ironically,

175
00:11:35.489 --> 00:11:39.585
this may make them more stable in
the sovereign dependent rights we are all

176
00:11:39.585 --> 00:11:40.130
used to.