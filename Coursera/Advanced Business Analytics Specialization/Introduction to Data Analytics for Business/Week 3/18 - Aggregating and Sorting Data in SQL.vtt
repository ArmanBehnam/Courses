WEBVTT

1
00:00:00.950 --> 00:00:05.500
In a previous video, we introduced some of
the basic commands used in SQL queries.

2
00:00:05.500 --> 00:00:09.910
We also explored column and row filtering
operations using the select, from, and

3
00:00:09.910 --> 00:00:11.240
where commands.

4
00:00:11.240 --> 00:00:14.980
In this video, we're going to
focus on data aggregations in SQL,

5
00:00:14.980 --> 00:00:19.770
using the group by command, filtering on
aggregate values using the having command,

6
00:00:19.770 --> 00:00:21.790
and sorting data using
the order by command.

7
00:00:23.340 --> 00:00:26.500
So what do we mean when
we say data aggregations?

8
00:00:26.500 --> 00:00:30.400
An aggregation basically takes
the values in multiple rows of data and

9
00:00:30.400 --> 00:00:31.890
returns one value.

10
00:00:31.890 --> 00:00:34.740
Effectively collapsing all
those rows into a single row

11
00:00:34.740 --> 00:00:36.890
containing a measure of interest.

12
00:00:36.890 --> 00:00:40.380
In the world of SQL we're really talking
about one of the following types of

13
00:00:40.380 --> 00:00:41.960
familiar operations.

14
00:00:41.960 --> 00:00:43.650
Each of which operates on a table field.

15
00:00:44.750 --> 00:00:49.570
The sum function calculates the arithmetic
sum across the sum of field values.

16
00:00:49.570 --> 00:00:51.260
Similarly, the average or

17
00:00:51.260 --> 00:00:54.940
AVG function calculates the average
across the sum of field values.

18
00:00:55.980 --> 00:00:59.920
Both the sum and average functions require
that the data in the field be numeric.

19
00:00:59.920 --> 00:01:03.340
They won't work on other types
of data like strings or dates.

20
00:01:03.340 --> 00:01:07.270
This is not the case for the min and the
max functions, which return the minimum or

21
00:01:07.270 --> 00:01:10.040
maximum values from a set of field values.

22
00:01:10.040 --> 00:01:13.740
The min and max functions will work
with most data types, including numbers,

23
00:01:13.740 --> 00:01:14.740
strings, or dates.

24
00:01:15.810 --> 00:01:19.510
The count function, returns the number
of values present in a field of values.

25
00:01:21.410 --> 00:01:25.020
Some SQL versions provide a few more
options for aggregate functions.

26
00:01:25.020 --> 00:01:28.820
But the ones we introduced here are pretty
universal across all versions you're

27
00:01:28.820 --> 00:01:30.390
likely to encounter.

28
00:01:30.390 --> 00:01:33.060
For all these functions
the syntax is similar.

29
00:01:33.060 --> 00:01:37.560
I have the function name immediately
followed by the field name in parenthesis.

30
00:01:37.560 --> 00:01:40.200
They also work pretty much as you
think they would, with one caveat.

31
00:01:41.340 --> 00:01:45.700
There's a special type of value that
can exist within a field called a null.

32
00:01:45.700 --> 00:01:48.780
A null basically represents
the absence of data.

33
00:01:48.780 --> 00:01:51.710
In other words there is
no value in that field.

34
00:01:51.710 --> 00:01:54.910
It shouldn't be confused with a zero or
a blank value.

35
00:01:54.910 --> 00:01:58.550
Which are actually real values
in American text fields.

36
00:01:58.550 --> 00:02:00.130
This distinction is important,

37
00:02:00.130 --> 00:02:03.510
because aggregate functions treat nulls
differently than they do other values.

38
00:02:04.530 --> 00:02:07.910
Specifically all aggregate
values ignore nulls except for

39
00:02:07.910 --> 00:02:10.470
one special case of the count function.

40
00:02:10.470 --> 00:02:14.310
If we use the wild card character
star in our count function,

41
00:02:14.310 --> 00:02:18.880
we return the number of rows in a data set
whether or not there are nulls present.

42
00:02:18.880 --> 00:02:23.500
That means that if I use count
field name and count star

43
00:02:23.500 --> 00:02:27.440
I'll get two different answers if there
are nulls in the fields of interest.

44
00:02:27.440 --> 00:02:30.970
Now that we've covered the types of
aggregate functions available to us,

45
00:02:30.970 --> 00:02:33.010
let's talk about how we
use them in queries.

46
00:02:34.070 --> 00:02:37.300
If we're interested in aggregate
values across an entire table,

47
00:02:37.300 --> 00:02:39.020
the syntax is pretty simple.

48
00:02:39.020 --> 00:02:43.120
We just use an aggregate function instead
of a field name in our select statement.

49
00:02:43.120 --> 00:02:47.920
For example, consider the transactions
table we introduced in a previous video.

50
00:02:47.920 --> 00:02:52.390
Since each row represents one transaction,
if we wanted to count the total number of

51
00:02:52.390 --> 00:02:55.690
transactions from the table
we'd use this query.

52
00:02:55.690 --> 00:03:00.040
As you can see we just select
count star from transactions.

53
00:03:00.040 --> 00:03:02.930
When we run this code we get
the following which tells me

54
00:03:02.930 --> 00:03:04.299
there are nine rows in this table.

55
00:03:05.730 --> 00:03:09.310
Depending on the specific version of
SQL you are using the query may or

56
00:03:09.310 --> 00:03:13.350
may not return a column name for
the aggregation in the output data set.

57
00:03:13.350 --> 00:03:15.720
In this case the column
name might be blank, or

58
00:03:15.720 --> 00:03:19.100
it might be the whole function COUNT(*).

59
00:03:19.100 --> 00:03:21.500
SQL Does provide us a way to specify or

60
00:03:21.500 --> 00:03:26.050
change a column name in our query through
the use of something called an alias.

61
00:03:26.050 --> 00:03:29.515
Let's say that we wanted to call the
number of rows in the transactions table

62
00:03:29.515 --> 00:03:32.040
num_rows.

63
00:03:32.040 --> 00:03:33.782
We could write a query
that looks like this.

64
00:03:33.782 --> 00:03:40.000
Here I have select count(*) as
num_rows from transactions.

65
00:03:40.000 --> 00:03:43.750
The as modifier tells the SQL engine
that I want to rename a field

66
00:03:43.750 --> 00:03:45.380
as something else.

67
00:03:45.380 --> 00:03:48.350
Running this query return
the same result as before

68
00:03:48.350 --> 00:03:52.940
except that the column of
the output set is now NUM_ROWS.

69
00:03:52.940 --> 00:03:56.370
The use of aliases is not
limited to aggregate functions.

70
00:03:56.370 --> 00:03:58.730
I can rename any field to
something else if I want to.

71
00:03:59.740 --> 00:04:02.890
We can also use aliases to
rename tables in our queries.

72
00:04:02.890 --> 00:04:04.370
But we'll cover that in a later video.

73
00:04:05.770 --> 00:04:10.480
As a side note, I'm using the underscore
character in my alias because SQL expects

74
00:04:10.480 --> 00:04:14.170
column and table names to be
a continuous set of characters,

75
00:04:14.170 --> 00:04:18.810
meaning I can't use spaces or
most punctuation marks in those names.

76
00:04:18.810 --> 00:04:22.860
If you put a space between words in a
table name, the SQL engine will interpret

77
00:04:22.860 --> 00:04:26.910
it as two separate things and
will most likely produce an error.

78
00:04:26.910 --> 00:04:31.030
So again we can use any of these
aggregate functions on the whole table.

79
00:04:31.030 --> 00:04:34.870
However a much more common use of
aggregate is in conjunction with the group

80
00:04:34.870 --> 00:04:35.440
by statement.

81
00:04:36.470 --> 00:04:40.380
As the name suggests, the group by
statement allows me to group data and

82
00:04:40.380 --> 00:04:42.479
provide summary aggregates for each group.

83
00:04:43.840 --> 00:04:47.750
Conceptually the way this works is
that I choose some way to group data

84
00:04:47.750 --> 00:04:50.620
that is based on one or
more of the fields in my table.

85
00:04:50.620 --> 00:04:53.230
then i determine what aggregates
I want based on one or

86
00:04:53.230 --> 00:04:55.400
more other fields in my table.

87
00:04:55.400 --> 00:04:57.820
The syntax of the SQL
code looks like this.

88
00:04:58.830 --> 00:05:03.180
Here I select some number of grouping
fields followed by some number of

89
00:05:03.180 --> 00:05:06.300
aggregates, all separated by commas,
like any other select state.

90
00:05:07.320 --> 00:05:10.900
The from clause is the same as
our previous queries, with from,

91
00:05:10.900 --> 00:05:11.910
followed by the table name.

92
00:05:12.970 --> 00:05:17.580
But now I add a third line, with group by,
followed by the same grouping

93
00:05:17.580 --> 00:05:20.660
fields I used in the select statement,
also separated by commas.

94
00:05:22.640 --> 00:05:25.380
The important thing to note about
this syntax is that anything in

95
00:05:25.380 --> 00:05:28.280
the select statement that's
not an aggregate function

96
00:05:28.280 --> 00:05:30.510
must also appear in
the group by statement.

97
00:05:31.740 --> 00:05:35.930
Let's see how this works with an example
using our transaction's table.

98
00:05:35.930 --> 00:05:39.980
Suppose that I'm interested in products
and I want a few different aggregates

99
00:05:39.980 --> 00:05:44.860
grouped by product, namely the total
number of purchases by product.

100
00:05:44.860 --> 00:05:47.980
The total dollar value
of purchases by product.

101
00:05:47.980 --> 00:05:50.400
And the average dollar value
of purchases by product.

102
00:05:52.150 --> 00:05:56.030
We saw earlier that we can get the total
number of purchases in our table by using

103
00:05:56.030 --> 00:05:57.830
the COUNT (*) function.

104
00:05:57.830 --> 00:06:01.480
To get the total dollar values of
purchases or use the sum function on

105
00:06:01.480 --> 00:06:05.150
the price column to get the average
dollar value of purchases,

106
00:06:05.150 --> 00:06:07.650
I use the average function,
also on the price column.

107
00:06:09.090 --> 00:06:10.920
To get this aggregate by product,

108
00:06:10.920 --> 00:06:14.450
I'll include then on this query
using the group by statement.

109
00:06:14.450 --> 00:06:18.750
Here, I select the product as the grouping
field then my three aggregate functions as

110
00:06:18.750 --> 00:06:22.830
aggregate fields I've added aliases for
each aggregate function so

111
00:06:22.830 --> 00:06:24.633
the output data function makes sense.

112
00:06:24.633 --> 00:06:30.660
I've called COUNT(*) PURCHASES,
the SUM(PRICE) TOTAL_SALES,

113
00:06:30.660 --> 00:06:34.570
and the Average (Price) AVG_SALES.

114
00:06:34.570 --> 00:06:38.560
I then have, FROM TRANSACTIONs,
and finally, I GROUP BY PRODUCT.

115
00:06:39.950 --> 00:06:42.020
When I run this query I
get the following output.

116
00:06:43.400 --> 00:06:46.550
Notice that the resulting data
set has one row per product,

117
00:06:46.550 --> 00:06:51.320
with each of my aggregates as columns:
purchases, total sales, and average sales.

118
00:06:52.760 --> 00:06:56.530
Now let's say I wanted to aggregate my
data, but I wanted to filter the output

119
00:06:56.530 --> 00:07:00.900
data set in some way based on the values
of the aggregates themselves.

120
00:07:00.900 --> 00:07:04.900
Previously when we wanted to filter
rows of data we used the where command.

121
00:07:04.900 --> 00:07:08.210
But when we want to filter rows of
data after they have been aggregated

122
00:07:08.210 --> 00:07:10.030
we use the having command.

123
00:07:10.030 --> 00:07:12.420
The syntax for
the having command looks like this.

124
00:07:14.000 --> 00:07:16.930
Everything is the same as for
the group by command, but

125
00:07:16.930 --> 00:07:20.070
now I've added a having command
to the end of the query,

126
00:07:20.070 --> 00:07:23.850
followed by some logical conditions
that qualify what to filter.

127
00:07:23.850 --> 00:07:27.350
The logical conditions themselves are
basically the same as those we use with

128
00:07:27.350 --> 00:07:28.520
the where command.

129
00:07:28.520 --> 00:07:32.100
Except that all the fields I reference
are aggregate fields versus fields from

130
00:07:32.100 --> 00:07:32.810
the source table.

131
00:07:34.250 --> 00:07:37.490
Again, let's use an example
to illustrate how this works.

132
00:07:37.490 --> 00:07:41.910
Let's start with the group, by example,
we just covered in the resulting data set.

133
00:07:41.910 --> 00:07:45.360
Let's say that what I really wanted to
see was summary of all products that had

134
00:07:45.360 --> 00:07:47.660
average sales greater than $10.

135
00:07:47.660 --> 00:07:49.570
In the output, books and

136
00:07:49.570 --> 00:07:54.550
DVDs each have average sales of
$14.95 which is greater than $10, but

137
00:07:54.550 --> 00:08:00.870
magazines have sales $2.875 which
is not greater than $10 the query

138
00:08:00.870 --> 00:08:05.650
to return only products with average
sales greater than $10 looks like this.

139
00:08:05.650 --> 00:08:10.145
Again the query is the same as our group
by example except that I've added having

140
00:08:10.145 --> 00:08:12.910
AVG_SALES greater than ten.

141
00:08:13.920 --> 00:08:16.880
When I run this query,
I get the expected result.

142
00:08:16.880 --> 00:08:19.860
Now I only have rows for books and DVDs.

143
00:08:19.860 --> 00:08:25.020
You'll notice that you use the alias, AVG
underscore sales in this having clause.

144
00:08:25.020 --> 00:08:29.640
Some SQL engines allow to use an alias
as an having statements others don't.

145
00:08:29.640 --> 00:08:31.560
If alias were not allowed,

146
00:08:31.560 --> 00:08:36.780
I will need to use the aggregate itself in
the having clause, in this case AVG price.

147
00:08:37.950 --> 00:08:40.370
It is possible to use both
the where command and

148
00:08:40.370 --> 00:08:42.630
the having command in the same query.

149
00:08:42.630 --> 00:08:46.830
When I do this, I'm basically
filtering rows from the source table,

150
00:08:46.830 --> 00:08:50.270
then aggregating using only
the rows I'm interested in.

151
00:08:50.270 --> 00:08:52.650
The syntax looks like this.

152
00:08:52.650 --> 00:08:55.860
Note that the where clause is right
after the from clause in my query,

153
00:08:55.860 --> 00:08:59.080
just like it was in our example
from the previous video.

154
00:08:59.080 --> 00:09:00.710
The having clause is still at the end.

155
00:09:02.220 --> 00:09:06.500
Let's say I still wanted to aggregate
using products on my transactions table,

156
00:09:06.500 --> 00:09:11.090
but I wanted to make sure I excluded data
from resellers and those aggregates.

157
00:09:11.090 --> 00:09:12.670
I write a query that looks like this.

158
00:09:14.100 --> 00:09:17.560
It's the same query from our having
example, except that I've added

159
00:09:17.560 --> 00:09:21.980
where channel is not equal to
reseller after the from clause.

160
00:09:21.980 --> 00:09:24.870
When I run this query,
I get the following data set.

161
00:09:24.870 --> 00:09:29.320
The output looks very similar to our
having example, except that the purchases,

162
00:09:29.320 --> 00:09:33.930
total sales, and average sales numbers for
DVDs have changed.

163
00:09:33.930 --> 00:09:36.610
Since we filtered out
the reseller DVD transaction.

164
00:09:38.290 --> 00:09:39.880
Okay, that's enough on aggregates for now.

165
00:09:39.880 --> 00:09:44.460
The last command we're going to talk about
in this video is the order by command.

166
00:09:44.460 --> 00:09:47.410
Recall that the older by commands
simply allows me to sort my

167
00:09:47.410 --> 00:09:50.230
output data set by one or
more sorting fields.

168
00:09:50.230 --> 00:09:52.190
For those of you familiar with Excel,

169
00:09:52.190 --> 00:09:56.250
the functionality is similar to the custom
sort feature that allows ascending and

170
00:09:56.250 --> 00:09:59.550
descending sorts based on
multiple columns of a table.

171
00:09:59.550 --> 00:10:02.490
The syntax for
the order by command is straight forward.

172
00:10:02.490 --> 00:10:06.380
I simply add order by to the end of my
query followed by a list of sorting fields

173
00:10:06.380 --> 00:10:10.340
separated by commas the sort
order is the sending by default.

174
00:10:10.340 --> 00:10:13.730
And the columns sorts sequences from
the left to right by the columns listed in

175
00:10:13.730 --> 00:10:14.830
the statement.

176
00:10:14.830 --> 00:10:19.370
In other words, the sort will be by
FIELD_i first then by the next field,

177
00:10:19.370 --> 00:10:21.100
etc all the way to field end.

178
00:10:22.200 --> 00:10:24.920
If I want the field to be
sorted in descending order,

179
00:10:24.920 --> 00:10:31.120
I simply add DESC after the field I want
sorted that way, separated by a space.

180
00:10:31.120 --> 00:10:34.370
One interesting thing to know is
that if I'm not aggravating data,

181
00:10:34.370 --> 00:10:38.110
the sort can usually be done using
any field in the source table,

182
00:10:38.110 --> 00:10:41.100
not just those fields contained
in the select statement.

183
00:10:41.100 --> 00:10:45.050
When I am aggravating data,
the order by statement must be based on

184
00:10:45.050 --> 00:10:46.999
the same elements there
in my select statement.

185
00:10:48.670 --> 00:10:51.460
As a final example,
let say I just wanted to see my whole

186
00:10:51.460 --> 00:10:54.880
transactions table sorted from
highest price to lowest price.

187
00:10:54.880 --> 00:10:56.000
I use the following query.

188
00:10:57.210 --> 00:11:02.310
Select star from transactions,
order by space desc.

189
00:11:03.420 --> 00:11:05.630
I then get the following result.

190
00:11:05.630 --> 00:11:06.290
As expected,

191
00:11:06.290 --> 00:11:10.870
I see all rows from the transactions table
sorted from highest price to lowest price.

192
00:11:10.870 --> 00:11:15.975
Note that in the case of sorting ties,
like the 2 transactions with a price of

193
00:11:15.975 --> 00:11:19.964
9.95, the default order is the same order
that exists in the source database table.

194
00:11:19.964 --> 00:11:24.940
Okay at this point we have covered
all the basic commands that we might

195
00:11:24.940 --> 00:11:26.710
run against the database table.

196
00:11:26.710 --> 00:11:30.480
We built on the select, from, and where
commands we covered in a prior video and

197
00:11:30.480 --> 00:11:33.540
added the group by, having,
and order by commands.

198
00:11:33.540 --> 00:11:37.070
You should now be able to write simply
queries to extract data from a database

199
00:11:37.070 --> 00:11:42.470
table, aggregate data, sort data, and
rename data using column aliases.

200
00:11:42.470 --> 00:11:45.953
In later videos, we'll talk about how
to extract data from multiple tables,

201
00:11:45.953 --> 00:11:47.978
and some more advanced
types of SQL queries.