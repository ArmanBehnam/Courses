WEBVTT

1
00:00:01.160 --> 00:00:05.210
Hi, in this video we're going to extend
our understanding of SQL by talking about

2
00:00:05.210 --> 00:00:08.310
how we can use operators to
create more complex conditions or

3
00:00:08.310 --> 00:00:10.640
data values in our queries.

4
00:00:10.640 --> 00:00:14.360
Operators are words or symbols that we
use in our code to define some sort of

5
00:00:14.360 --> 00:00:16.430
condition among data elements.

6
00:00:16.430 --> 00:00:19.440
Most of these are probably
familiar to you in concept but

7
00:00:19.440 --> 00:00:22.300
here we'll talk about how
to use them in our SQL.

8
00:00:22.300 --> 00:00:25.340
Specifically we'll talk about
three types of operators,

9
00:00:25.340 --> 00:00:30.200
comparison operators, arithmetic
operators, and logical operators.

10
00:00:30.200 --> 00:00:33.290
Here's a summary of the operators
we'll cover in each category.

11
00:00:33.290 --> 00:00:36.420
If you're just listening, don't worry
we'll list each of them as we go forward.

12
00:00:37.890 --> 00:00:41.560
The first type of operators we'll
talk about are comparison operators.

13
00:00:41.560 --> 00:00:45.300
Comparison operators help to find whether
a condition between two fields or

14
00:00:45.300 --> 00:00:47.250
functions of fields is true or false.

15
00:00:48.260 --> 00:00:51.400
Here are the comparison
operators available in SQL.

16
00:00:51.400 --> 00:00:53.120
This shall look pretty familiar.

17
00:00:53.120 --> 00:00:57.680
We have equal to, less than,
greater than, less than or equal to, and

18
00:00:57.680 --> 00:00:59.300
greater than or equal to.

19
00:00:59.300 --> 00:01:02.780
We also have the equivalent operators
less than or greater than and

20
00:01:02.780 --> 00:01:06.240
not equal to where not is
represented by an exclamation point.

21
00:01:07.260 --> 00:01:09.470
Similarly, we have not greater than and

22
00:01:09.470 --> 00:01:11.900
not less than also using
the exclamation point.

23
00:01:13.290 --> 00:01:16.230
We touched on this with some of our
related videos where we talked about

24
00:01:16.230 --> 00:01:18.010
where and having statement.

25
00:01:18.010 --> 00:01:22.020
In fact that's primarily where these type
of operators are used, to establish some

26
00:01:22.020 --> 00:01:26.310
criteria by which rows or aggregate
rows are filtered from a data set.

27
00:01:26.310 --> 00:01:30.200
To use comparison operators we place
them between two fields, functions and

28
00:01:30.200 --> 00:01:31.700
fields or fixed values.

29
00:01:33.250 --> 00:01:36.059
Here's a couple of examples using
where and having statements.

30
00:01:37.520 --> 00:01:41.100
Here, we have a where clause,
which is true when field A is less than or

31
00:01:41.100 --> 00:01:42.600
equal to field B.

32
00:01:42.600 --> 00:01:47.050
And a having clause, which is true when
the sum of field C is not equal to 100.

33
00:01:47.050 --> 00:01:51.605
The second type of operators
are arithmetic operators,

34
00:01:51.605 --> 00:01:55.620
namely plus for addition,
minus for subtraction, star for

35
00:01:55.620 --> 00:01:59.280
multiplication and
forward slash for division.

36
00:01:59.280 --> 00:02:04.420
Most SQL engines also support the modulus
operator, represented as a percent sign

37
00:02:04.420 --> 00:02:07.500
which returns the remainder of one
value divided by another value.

38
00:02:08.600 --> 00:02:11.960
We can use arithmetic operators
in a couple of different ways.

39
00:02:11.960 --> 00:02:15.090
We can use them in conjunction with
comparison operators in where and

40
00:02:15.090 --> 00:02:18.510
having statements to construct more
complex conditions like these.

41
00:02:19.830 --> 00:02:23.860
Again, we have a where clause which
is true when FIELD_A + FIELD_B

42
00:02:23.860 --> 00:02:24.770
is equal to FIELD_C.

43
00:02:24.770 --> 00:02:29.637
And the having clause which is true
when sum of FIELD_D minus 100 is greater

44
00:02:29.637 --> 00:02:32.081
than the sum of FIELD_E divided by 2.

45
00:02:33.340 --> 00:02:36.260
Note that I can use arithmetic
operations on either side or

46
00:02:36.260 --> 00:02:38.820
both sides of the comparison operator.

47
00:02:38.820 --> 00:02:42.830
Note also that the calculations are done
in normal arithmetic order with division

48
00:02:42.830 --> 00:02:47.460
and multiplication operations taking
precedence over addition and subtraction.

49
00:02:47.460 --> 00:02:50.730
For more complex operations I can
use parentheses just like I would

50
00:02:50.730 --> 00:02:54.490
in common math equations to achieve
the right order of operations like this.

51
00:02:55.650 --> 00:02:59.710
Here I use parenthesis to ensure that
the addition operation happens before

52
00:02:59.710 --> 00:03:01.510
the division operation.

53
00:03:01.510 --> 00:03:05.320
The other place I can use arithmetic
operations is in my select statement.

54
00:03:05.320 --> 00:03:08.090
I can create calculation
within rows of a data set

55
00:03:08.090 --> 00:03:11.620
to construct new columns based on
other columns on that row like these.

56
00:03:13.630 --> 00:03:18.920
Here, I add FIELD_A to FIELD_B in each row
and put it in a new field called FIELD_N.

57
00:03:18.920 --> 00:03:22.570
Be careful not to confuse this type of
operation with aggregation functions like

58
00:03:22.570 --> 00:03:26.530
the sum function, which are designed
to aggregate data across rows

59
00:03:26.530 --> 00:03:28.650
when a group by command is used.

60
00:03:28.650 --> 00:03:33.620
Simple arithmetic operators worked
within one row of data across columns.

61
00:03:33.620 --> 00:03:37.690
However, I can use arithmetic operations
with aggregation functions as well

62
00:03:37.690 --> 00:03:38.310
like this.

63
00:03:40.766 --> 00:03:44.046
A select statement is an aggregation
intended to be used by the group by

64
00:03:44.046 --> 00:03:44.995
statement.

65
00:03:44.995 --> 00:03:48.732
Here fields C and D are first aggregated
using the sum function and then

66
00:03:48.732 --> 00:03:53.174
those sums are added together to produce
field N in the aggregated output data set.

67
00:03:54.870 --> 00:03:57.740
The third type of operators we'll
cover are logical operator.

68
00:03:57.740 --> 00:04:01.650
There are actually quite a few
logical operators available in SQL

69
00:04:01.650 --> 00:04:05.130
including some that are unique
to specific SQL engines.

70
00:04:05.130 --> 00:04:08.870
Just about all of them are primarily
used in where or having clauses as

71
00:04:08.870 --> 00:04:13.110
we are trying to define specific
conditions for row or aggregate faltering.

72
00:04:13.110 --> 00:04:16.050
Here we will discuss a few of
the most common logical operators

73
00:04:16.050 --> 00:04:18.060
that you're likely to use in
day-to-day query writing.

74
00:04:18.060 --> 00:04:23.420
We'll start with two familiar logical
operators called Boolean operators,

75
00:04:23.420 --> 00:04:24.860
and and or.

76
00:04:24.860 --> 00:04:27.230
We generally use these
operators in a where or

77
00:04:27.230 --> 00:04:31.270
have in clause where we want to include
more than one condition in the clause.

78
00:04:31.270 --> 00:04:32.320
When we use and,

79
00:04:32.320 --> 00:04:35.690
it means that all conditions in
our statement need to be true.

80
00:04:35.690 --> 00:04:39.470
When we use or, it means that at least
one of the conditions in our statement

81
00:04:39.470 --> 00:04:40.780
needs to be true.

82
00:04:40.780 --> 00:04:43.830
I can represent the situation
visual when using a Venn diagram.

83
00:04:44.880 --> 00:04:48.430
In the diagram, the shaded portion
represents the condition under which some

84
00:04:48.430 --> 00:04:50.260
overall statement is true.

85
00:04:50.260 --> 00:04:52.560
In SQL code,
it might look something like this.

86
00:04:53.980 --> 00:04:55.020
In the where clause,

87
00:04:55.020 --> 00:04:58.540
the overall statement is true only
when both conditions are true.

88
00:04:58.540 --> 00:05:02.270
Field A is less than 10 and
field B is greater than 100.

89
00:05:02.270 --> 00:05:03.532
And the having clause,

90
00:05:03.532 --> 00:05:07.760
the overall statement is true when
either of the conditions are true.

91
00:05:07.760 --> 00:05:11.260
The sum of field C is equal to 50 or

92
00:05:11.260 --> 00:05:13.884
the minimum of field D is greater or
equal to 5.

93
00:05:15.190 --> 00:05:16.610
Like arithmetic operators,

94
00:05:16.610 --> 00:05:20.130
I can construct much more complex
conditions using a combination of and

95
00:05:20.130 --> 00:05:25.430
operators, or operators and parenthetical
expressions to achieve the outcome I want.

96
00:05:25.430 --> 00:05:28.720
Again, a little creativity can
go a long way in writing SQL.

97
00:05:29.810 --> 00:05:33.328
The next logical operator we'll
discuss is the in operator.

98
00:05:33.328 --> 00:05:37.467
The in operator allows us to set up
a condition to determine whether a field

99
00:05:37.467 --> 00:05:41.902
value or a expression is contained within
a specific list of possible values.

100
00:05:41.902 --> 00:05:45.414
You can think of the in operator as
short hand for a long list of or

101
00:05:45.414 --> 00:05:48.546
conditions I might include in a where or
having clause.

102
00:05:48.546 --> 00:05:54.641
For example, I could write this,
where FIELD_A equals AAA or

103
00:05:54.641 --> 00:05:59.030
FIELD_A equals BBB or FIELD_A equals CCC.

104
00:05:59.030 --> 00:06:06.489
Or I could write this where
FIELD_A in AAA, BBB, CCC.

105
00:06:06.489 --> 00:06:08.757
As the list of possible values gets large,

106
00:06:08.757 --> 00:06:12.000
using the in operator makes
my code a lot simpler.

107
00:06:12.000 --> 00:06:16.280
It's also useful when my list of possible
values is defined by a sub-query.

108
00:06:16.280 --> 00:06:18.060
We discuss this case in a separate video.

109
00:06:19.320 --> 00:06:22.340
Another time saving operator
is the between operator,

110
00:06:22.340 --> 00:06:24.840
which allows us to set up
a condition where a field or

111
00:06:24.840 --> 00:06:28.150
expression is between two other values or
expressions.

112
00:06:28.150 --> 00:06:30.160
Again, this is really just a shorthand for

113
00:06:30.160 --> 00:06:34.360
a compound condition using comparison
operators and the and operator.

114
00:06:34.360 --> 00:06:38.240
For example, I could write this,
WHERE FIELD_A is greater than or

115
00:06:38.240 --> 00:06:41.040
equal to 10 and
FIELD_A is less than or equal to 100.

116
00:06:41.040 --> 00:06:46.760
Or I could write this,
WHERE FIELD_A between 10 and 100.

117
00:06:46.760 --> 00:06:52.230
The like operator is a powerful
operator that has a lot of flexibility.

118
00:06:52.230 --> 00:06:55.190
But its syntax is also
a bit more involved.

119
00:06:55.190 --> 00:06:59.030
The like operator basically searches for a
specific set of characters in a string or

120
00:06:59.030 --> 00:07:02.900
text field and
returns a true result if there is a match.

121
00:07:02.900 --> 00:07:06.830
The tricky part about using like is that
I usually need to incorporate one or

122
00:07:06.830 --> 00:07:10.130
more wild card characters that
indicate where in the string I

123
00:07:10.130 --> 00:07:12.450
expect the pattern to occur.

124
00:07:12.450 --> 00:07:16.550
The two most common wild card
characters we use are the following.

125
00:07:16.550 --> 00:07:20.750
The percent symbol means any
string of zero or more characters.

126
00:07:20.750 --> 00:07:24.170
The underscore character
means any single character.

127
00:07:24.170 --> 00:07:27.194
It's probably easiest to illustrate
how they work with a few examples.

128
00:07:29.009 --> 00:07:32.443
This condition will be true for
any string that starts with abc,

129
00:07:32.443 --> 00:07:34.549
regardless of how long that string is.

130
00:07:36.410 --> 00:07:39.906
This condition will only be true
if the string starts with abc and

131
00:07:39.906 --> 00:07:41.339
is four characters long.

132
00:07:43.742 --> 00:07:46.261
This condition will be
true if the sub-string

133
00:07:46.261 --> 00:07:49.200
abc appears anywhere in the string.

134
00:07:49.200 --> 00:07:50.920
You get the idea.

135
00:07:50.920 --> 00:07:54.830
This last case is probably those common
when where using the like operator.

136
00:07:54.830 --> 00:07:57.340
But there are a number of
different ways I can use wildcards

137
00:07:57.340 --> 00:08:00.330
including some that we won't cover here,
to get the desired result.

138
00:08:02.220 --> 00:08:05.410
One special condition will add to our
discussion of logical operators is

139
00:08:05.410 --> 00:08:07.350
the IS NULL condition.

140
00:08:07.350 --> 00:08:11.490
This is a special condition that is true
when a field or expression is a null

141
00:08:11.490 --> 00:08:16.220
which you may recall is a special database
value that indicates the absence of data.

142
00:08:16.220 --> 00:08:18.130
The syntax is pretty simple.

143
00:08:18.130 --> 00:08:24.735
For example, I use IS NULL in a WHERE
clause like this, WHERE FIELD_A IS NULL.

144
00:08:24.735 --> 00:08:27.983
In analytics we use this
condition quite a bit to look for

145
00:08:27.983 --> 00:08:32.421
whole scenario of data where the field
route row do not have the data we need.

146
00:08:32.421 --> 00:08:36.685
The last logical operator we will
talk about is the NOT operator.

147
00:08:36.685 --> 00:08:40.920
NOT basically reverses the logical
meaning of other logical operators.

148
00:08:40.920 --> 00:08:43.610
Technically, I can use it
with pretty any operator.

149
00:08:43.610 --> 00:08:46.840
But there are only a few cases
where it really makes sense.

150
00:08:46.840 --> 00:08:49.730
The fist is in conjunction with the AND
operator.

151
00:08:49.730 --> 00:08:52.070
Remember our AND and OR in Venn diagrams?

152
00:08:53.080 --> 00:08:55.870
Well, there's a third case of
the diagram you might be interested in,

153
00:08:55.870 --> 00:08:57.520
namely this one.

154
00:08:57.520 --> 00:09:01.540
The shaded part of the diagram represents
the case where one condition is true or

155
00:09:01.540 --> 00:09:04.910
the other condition is true,
but not both conditions.

156
00:09:04.910 --> 00:09:07.790
Here's an example of a query
that uses NOT with an and

157
00:09:07.790 --> 00:09:10.200
operator, to achieve
this type of situation.

158
00:09:11.980 --> 00:09:16.725
So here we're looking for any case except
those where FIELD_A is less that ten and

159
00:09:16.725 --> 00:09:18.149
FIELD_B is greater than 100.

160
00:09:19.270 --> 00:09:22.810
The other common cases where we use
the NOT operator is with the LIKE and

161
00:09:22.810 --> 00:09:24.380
IS NULL operators.

162
00:09:24.380 --> 00:09:26.402
These cases are a little
more straight forward so

163
00:09:26.402 --> 00:09:28.678
we'll just illustrate it
using a couple of examples.

164
00:09:31.035 --> 00:09:35.760
This condition is true whenever FIELD_A
does not contain the sub string abc.

165
00:09:37.350 --> 00:09:42.140
Similarly, this condition is true when
the value of FIELD_A is anything except

166
00:09:42.140 --> 00:09:42.949
a database null.

167
00:09:45.070 --> 00:09:47.200
So we've covered quite
a lot up to this point.

168
00:09:47.200 --> 00:09:51.050
Again there are number of logical
operators that are available in SQL but

169
00:09:51.050 --> 00:09:53.870
the ones we've covered
are by far the most common.

170
00:09:53.870 --> 00:09:57.630
Let's quickly recap, we covered three
types of operators that can expand

171
00:09:57.630 --> 00:10:00.040
the usefulness of our SQL queries.

172
00:10:00.040 --> 00:10:02.820
We introduced comparison operators
which helped determine whether our

173
00:10:02.820 --> 00:10:06.260
condition between two fields
are expressions of true or false.

174
00:10:06.260 --> 00:10:10.560
We then talked about arithmetic operators
which we can use a comparative expressions

175
00:10:10.560 --> 00:10:12.540
or to transform values and
select statements.

176
00:10:13.620 --> 00:10:16.640
Finally, we presented a set
of common logical operators

177
00:10:16.640 --> 00:10:19.710
which helped us represent a variety of
different conditions and or where or

178
00:10:19.710 --> 00:10:20.370
having statements.

179
00:10:21.950 --> 00:10:23.620
Hopefully you've got an appreciation for

180
00:10:23.620 --> 00:10:26.590
how much power these operators
add to our SQL queries and

181
00:10:26.590 --> 00:10:30.080
how they give us the flexibility to
create some pretty complex condition.

182
00:10:30.080 --> 00:10:33.437
With the goal of the given exactly
the day we need for our analysis.