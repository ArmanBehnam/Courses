WEBVTT

1
00:00:01.220 --> 00:00:04.386
Welcome back, today we begin our
module on analytical technologies.

2
00:00:04.386 --> 00:00:07.042
In this module,
we'll focus on the applications and

3
00:00:07.042 --> 00:00:09.887
tools that are used to store,
extract and analyze data.

4
00:00:09.887 --> 00:00:14.837
In our first module, we learnt how events
and characteristics in the real world,

5
00:00:14.837 --> 00:00:16.870
are captured by source systems.

6
00:00:16.870 --> 00:00:19.410
In this video, we'll definitely
pick up where we left off, and

7
00:00:19.410 --> 00:00:22.660
talk about the various ways
in which data can be stored.

8
00:00:22.660 --> 00:00:25.630
Given that we're potentially capturing
massive amounts of data in our

9
00:00:25.630 --> 00:00:26.720
source systems.

10
00:00:26.720 --> 00:00:29.970
It's natural to ask where
the heck does all the stuff go?

11
00:00:29.970 --> 00:00:33.310
Well, it turns out that each source
usually has it's own storage system to

12
00:00:33.310 --> 00:00:35.635
hold data relevant to that system.

13
00:00:35.635 --> 00:00:40.595
Unfortunately, that isn't necessarily
ideal for us as analyst for a few reasons.

14
00:00:40.595 --> 00:00:44.285
First, it's likely that the source's
storage system is optimized for

15
00:00:44.285 --> 00:00:48.655
functional performance, not for
data extraction and analysis.

16
00:00:48.655 --> 00:00:53.865
As an example, you may have seen the terms
online transactional processing or OLTP.

17
00:00:54.900 --> 00:00:59.510
An Online Analytical Processing OLAP or
OLAP.

18
00:00:59.510 --> 00:01:03.370
These terms refer to storage systems that
are optimized for business operations and

19
00:01:03.370 --> 00:01:06.660
transactions versus those that
are optimized for analytics.

20
00:01:08.005 --> 00:01:11.635
While it's possible to perform
analytics on transactional systems,

21
00:01:11.635 --> 00:01:15.445
it's often much easier to do
it on analytical systems.

22
00:01:15.445 --> 00:01:18.155
The second challenge with source
store storage systems is that they

23
00:01:18.155 --> 00:01:22.015
often contain a lot more information
than we really need for analytics.

24
00:01:22.015 --> 00:01:26.455
It's not uncommon for a source database to
contain all sorts of internal working data

25
00:01:26.455 --> 00:01:30.020
that really doesn't have a use
outside the system operation.

26
00:01:30.020 --> 00:01:34.120
We prefer not to have to carry all that
extra data indoor analytical environment.

27
00:01:35.130 --> 00:01:38.400
We also need to remember the source
system can be critical to the day to

28
00:01:38.400 --> 00:01:40.320
day operation of the business.

29
00:01:40.320 --> 00:01:44.317
We may not want to risk slowing down or
even crashing those systems by allowing

30
00:01:44.317 --> 00:01:47.451
direct access to system data
by analytical applications.

31
00:01:47.451 --> 00:01:52.018
Finally, because source systems often
deal with very high volumes of data,

32
00:01:52.018 --> 00:01:53.565
they may not store data for

33
00:01:53.565 --> 00:01:58.560
very long in order to optimize
the overall performance of that system.

34
00:01:58.560 --> 00:02:00.580
This means that if we want the data, or

35
00:02:00.580 --> 00:02:04.600
some subset of the data, to be
available for a longer period of time,

36
00:02:04.600 --> 00:02:07.319
we need to grab it and
put it in a longer term storage location.

37
00:02:09.250 --> 00:02:12.940
As we mentioned earlier, we do sometimes
connect to record resource systems

38
00:02:12.940 --> 00:02:15.680
especially when we access
to real time data.

39
00:02:15.680 --> 00:02:18.980
We may even intercept data as it
streams through a connection point.

40
00:02:20.240 --> 00:02:22.960
However, a more common
solution is to gather data

41
00:02:22.960 --> 00:02:25.040
into a separate storage location.

42
00:02:25.040 --> 00:02:29.900
This may be a central data repository,
where data is physically colocated.

43
00:02:29.900 --> 00:02:33.760
It could also be a virtual repository,
where the data is physically located in

44
00:02:33.760 --> 00:02:38.690
different places but appears to the user
as though it's in a common location.

45
00:02:38.690 --> 00:02:42.900
And it could be a combination of these two
things or a semi-centralized repository.

46
00:02:44.780 --> 00:02:47.540
So we've talked a bit about
where we store information.

47
00:02:47.540 --> 00:02:51.300
Let's change gears a little and
talk about how we store information.

48
00:02:51.300 --> 00:02:55.330
There are many ways to store data, but
here we'll cover the two broad mechanisms

49
00:02:55.330 --> 00:02:59.520
that you're most likely to see in
the world of analytics, data files and

50
00:02:59.520 --> 00:03:00.300
databases.

51
00:03:01.450 --> 00:03:04.570
We'll cover a number of common
data types in a few minutes but

52
00:03:04.570 --> 00:03:07.550
it's useful the first
talk about file systems.

53
00:03:07.550 --> 00:03:10.320
A file system is basically
just the digital equivalent of

54
00:03:10.320 --> 00:03:12.050
an organized file cabinet.

55
00:03:12.050 --> 00:03:15.110
I take pieces of information,
I put them into a folder and

56
00:03:15.110 --> 00:03:17.780
perhaps put that folder
into a larger folder.

57
00:03:17.780 --> 00:03:19.270
Think about your own computer,

58
00:03:19.270 --> 00:03:22.000
this is how you probably store
most things on your PC or Mac.

59
00:03:23.050 --> 00:03:25.680
The nice thing about a file system
is that I can put pretty much

60
00:03:25.680 --> 00:03:29.200
anything I want there and just note it's
name and location so I can find it later.

61
00:03:30.270 --> 00:03:33.950
File systems are attractive in that they
can handle all sorts of information,

62
00:03:33.950 --> 00:03:36.700
including what we call unstructured data.

63
00:03:36.700 --> 00:03:41.150
We can store documents, spreadsheets,
pictures, music, video, you name it.

64
00:03:41.150 --> 00:03:43.960
The file system doesn't really
care what's in the file.

65
00:03:43.960 --> 00:03:46.890
The downside of storing data in
file systems is that it's not

66
00:03:46.890 --> 00:03:48.900
as obvious how it accessed the data,

67
00:03:48.900 --> 00:03:52.030
given that you are sending in
a bunch of different file locations.

68
00:03:52.030 --> 00:03:56.111
It's also unclear how I perform data
analysis on something like a document,

69
00:03:56.111 --> 00:04:00.129
photo or a video without some sort of
intermediate processing to turn it into

70
00:04:00.129 --> 00:04:01.731
something more structural.

71
00:04:01.731 --> 00:04:07.110
One important example of a file system
is the Hadoop Distributed File System or

72
00:04:07.110 --> 00:04:11.848
HDFS, which is a big data manifestation
of the file system concept.

73
00:04:11.848 --> 00:04:16.001
HDFS uses massively parallel
processing on relatively inexpensive

74
00:04:16.001 --> 00:04:20.870
infrastructure to efficiently store very
large amounts of information without

75
00:04:20.870 --> 00:04:23.530
much regard to the data type.

76
00:04:23.530 --> 00:04:27.360
We'll talk a bit more about big
data technologies in a later video.

77
00:04:27.360 --> 00:04:29.560
So, what about the data files themselves?

78
00:04:29.560 --> 00:04:31.500
There are many types of data files.

79
00:04:31.500 --> 00:04:35.060
Think of all the different extensions
that files on your computer have but

80
00:04:35.060 --> 00:04:38.590
there are few file types that come up most
often in the world of data analytics.

81
00:04:40.050 --> 00:04:43.210
The first is what's called
a delimited text file.

82
00:04:43.210 --> 00:04:46.100
Normally, a delimited text file
contains data that represents

83
00:04:46.100 --> 00:04:49.600
a two dimensional table with columns and
rows.

84
00:04:49.600 --> 00:04:53.150
That data itself is stored as text
with breaks between the columns and

85
00:04:53.150 --> 00:04:58.460
rows, identified using specific characters
or formatting codes called delimiters.

86
00:04:58.460 --> 00:05:02.640
The most common delimiters are commas,
tabs and pipes.

87
00:05:02.640 --> 00:05:05.620
The pipe is the vertical line
character you see on your keyboard.

88
00:05:06.720 --> 00:05:11.250
You'll often see comma delimited files
with the extension CSV which stands for

89
00:05:11.250 --> 00:05:13.580
comma separated values.

90
00:05:13.580 --> 00:05:18.010
Tab and pipe delimited files usually
just have the TXT text file extension.

91
00:05:19.350 --> 00:05:22.930
The nice thing about text files is that
they are understood by wide variety of

92
00:05:22.930 --> 00:05:24.860
systems and analytical tools.

93
00:05:24.860 --> 00:05:27.590
So it's pretty straight forward to
move data from one environment to

94
00:05:27.590 --> 00:05:28.899
another using this file format.

95
00:05:30.560 --> 00:05:35.600
A second file type is
an Extensible Markup Language or XML file.

96
00:05:35.600 --> 00:05:39.730
XML is a flexible structure of encoding
documents and data that was developed in

97
00:05:39.730 --> 00:05:44.210
the late 90s, primarily to facilitate
data sharing over the Internet.

98
00:05:44.210 --> 00:05:47.780
However, it has a wide range of
applications from web pages to

99
00:05:47.780 --> 00:05:50.420
applications to messaging systems.

100
00:05:50.420 --> 00:05:54.390
The nice thing about XML is that it is
a common standard and it allows for

101
00:05:54.390 --> 00:05:58.790
a more complex structuring of data that
something like I'm doing the text file.

102
00:05:58.790 --> 00:06:02.160
The downside is that it requires
a more sophisticated interface

103
00:06:02.160 --> 00:06:04.419
to interpret the data and
structure for analysis.

104
00:06:06.330 --> 00:06:08.980
A third type of file is a log file.

105
00:06:08.980 --> 00:06:12.630
Log files are generally used to
capture event data from a system and

106
00:06:12.630 --> 00:06:16.090
are common in machine data, messaging and
web analytics applications.

107
00:06:17.330 --> 00:06:20.290
Log files may or
may not follow a standard structure and

108
00:06:20.290 --> 00:06:24.310
they generally require something called
a parser to read and interpret the file.

109
00:06:25.380 --> 00:06:28.315
The advantage of log files is
that they are very flexible,

110
00:06:28.315 --> 00:06:31.120
it can capture just about
any data structure you want.

111
00:06:31.120 --> 00:06:34.770
However, this comes at the expense of
a much more complicated process for

112
00:06:34.770 --> 00:06:36.350
reading and using the data.

113
00:06:36.350 --> 00:06:40.520
In fact, there are specific software tools
that specialize in parsing log files.

114
00:06:41.980 --> 00:06:45.117
The last type of data file we'll
discuss is really a class of

115
00:06:45.117 --> 00:06:48.078
files that are specific to
common data analysis tools.

116
00:06:48.078 --> 00:06:51.562
Most tools have their own proprietary
file formats for storing data,

117
00:06:51.562 --> 00:06:53.994
along with other information
called metadata.

118
00:06:53.994 --> 00:06:59.480
Which describes calculations, operations,
or other attributes of the data itself.

119
00:06:59.480 --> 00:07:03.680
Far and away, the most common of these
is the Microsoft Excel spreadsheet file.

120
00:07:03.680 --> 00:07:06.880
Even though there are a lot of
sophisticated analysis tools out there,

121
00:07:06.880 --> 00:07:09.800
the reality is that
a disproportionate amount of actual

122
00:07:09.800 --> 00:07:12.030
analytical work is done in Excel.

123
00:07:12.030 --> 00:07:14.270
And that's not necessarily a bad thing,

124
00:07:14.270 --> 00:07:17.670
just about everyone knows how
to do basic operations in Excel.

125
00:07:17.670 --> 00:07:21.930
And there are certain things that are
quite frankly just easier to do in Excel,

126
00:07:21.930 --> 00:07:25.530
making it a very flexible tool for
both manipulating and sharing data and

127
00:07:25.530 --> 00:07:27.320
analytical results.

128
00:07:27.320 --> 00:07:31.090
However, Excel is just one of
many specialized file formats.

129
00:07:31.090 --> 00:07:35.920
Tools like SaaS, SPSS, Tableau, and
a whole host of other applications

130
00:07:35.920 --> 00:07:39.970
each have their own specific formats for
storing data in standalone files.

131
00:07:39.970 --> 00:07:43.680
Broadly, this means you may need to use
that specific application to open and

132
00:07:43.680 --> 00:07:44.980
use those files.

133
00:07:44.980 --> 00:07:47.620
But increasingly,
applications are opening up a bit and

134
00:07:47.620 --> 00:07:51.360
building in the ability to ingest and
interpret other file types.

135
00:07:51.360 --> 00:07:52.540
It really depends on the tool.

136
00:07:53.950 --> 00:07:56.410
Okay, so we talked about data files.

137
00:07:56.410 --> 00:07:58.840
Now let's move on to databases.

138
00:07:58.840 --> 00:08:01.990
A database is simply
an organize collection of data.

139
00:08:01.990 --> 00:08:05.460
When we say database, we're usually
referring to both the structure and

140
00:08:05.460 --> 00:08:09.020
design of a data environment,
as well as the data itself.

141
00:08:09.020 --> 00:08:12.170
A database seeks to store
data in a more complex way

142
00:08:12.170 --> 00:08:14.300
than what could be
achieved in a data file.

143
00:08:14.300 --> 00:08:18.410
Specifically, a database usually stores
a number of different date entities

144
00:08:18.410 --> 00:08:23.000
with some unifying information about how
those entities are arranged or related.

145
00:08:23.000 --> 00:08:27.400
This enables access to a wider array of
information in one common environment.

146
00:08:27.400 --> 00:08:30.371
Versus storing that information in
multiple data files that may or

147
00:08:30.371 --> 00:08:31.546
may not be tied together.

148
00:08:31.546 --> 00:08:36.923
Usually, a database is constructed using
a Database Management System or DBMS.

149
00:08:36.923 --> 00:08:40.609
A Database Management System is
a software application use for

150
00:08:40.609 --> 00:08:43.680
creating, maintaining and
accessing databases.

151
00:08:44.920 --> 00:08:47.770
There are variety of different
types of databases but far and

152
00:08:47.770 --> 00:08:50.730
away the most common is
the Relational Database.

153
00:08:50.730 --> 00:08:54.640
In fact, the relational database is so
important that we'll spend a later video

154
00:08:54.640 --> 00:08:57.880
in this module talking in detail
about this type of database.

155
00:08:57.880 --> 00:09:01.000
And we'll spend all of module
three learning how to extract data

156
00:09:01.000 --> 00:09:03.300
from relational databases.

157
00:09:03.300 --> 00:09:07.150
The basic concept behind relational
databases, is that we store information in

158
00:09:07.150 --> 00:09:12.270
two dimensional tables, and then to find
specific relationships among those tables.

159
00:09:12.270 --> 00:09:15.829
It turns out that this can be a really
efficient and effective way of storing

160
00:09:15.829 --> 00:09:19.635
data that is pretty easy to understand
which contributes to it's popularity.

161
00:09:19.635 --> 00:09:24.923
The idea was developed by a computer
scientist named EF Codd at IBM in 1969 and

162
00:09:24.923 --> 00:09:25.715
1970.

163
00:09:25.715 --> 00:09:29.878
Given that it's been nearly 50 years
since then, it's pretty impressive that

164
00:09:29.878 --> 00:09:33.629
the relational database remains
the dominant paradigm in data storage.

165
00:09:34.750 --> 00:09:38.850
That having been said, the relational
database is not the only type of database.

166
00:09:38.850 --> 00:09:41.600
In fact, there are a number of
emerging types of databases that

167
00:09:41.600 --> 00:09:45.760
are being used to handle special types
of data, store unstructured data, or

168
00:09:45.760 --> 00:09:48.230
improve performance in
the era of big data.

169
00:09:49.240 --> 00:09:52.170
Let's talk about four common
Alternative Databases.

170
00:09:52.170 --> 00:09:57.190
Graph Databases, Document Stores,
Columnar Databases, and Key-Value Stores.

171
00:09:58.400 --> 00:10:01.120
A graph database is based on graph theory,
or

172
00:10:01.120 --> 00:10:04.870
the study of para-wise
relationships between objects.

173
00:10:04.870 --> 00:10:08.430
These databases tend to work well
with highly interconnected data,

174
00:10:08.430 --> 00:10:11.340
like relationships between people or
locations and

175
00:10:11.340 --> 00:10:14.880
have applications in physical and
social network analysis.

176
00:10:14.880 --> 00:10:19.730
A document store, as its name suggests,
is generally designed to store documents,

177
00:10:19.730 --> 00:10:23.460
along with key pieces of metadata
describing those documents.

178
00:10:23.460 --> 00:10:27.780
It's useful for storing unstructured data
or different data types in a way that's

179
00:10:27.780 --> 00:10:30.750
a little more useful than
a typical file system.

180
00:10:30.750 --> 00:10:35.120
Columnar databases are storage mechanisms
which seek to improve the performance of

181
00:10:35.120 --> 00:10:36.270
data access.

182
00:10:36.270 --> 00:10:38.545
By focusing on columns of data tables,

183
00:10:38.545 --> 00:10:42.140
versus the row based approach
of relational database systems.

184
00:10:42.140 --> 00:10:44.670
It turns that when we write
information into a database,

185
00:10:44.670 --> 00:10:46.800
we usually do it row by row.

186
00:10:46.800 --> 00:10:49.990
Which makes sense when each row of data
represents something like a purchase

187
00:10:49.990 --> 00:10:52.200
transaction or a new customer.

188
00:10:52.200 --> 00:10:56.030
However, when we extract data
from databases we're usually more

189
00:10:56.030 --> 00:10:59.700
interested in summarizing some
attribute across all rows.

190
00:10:59.700 --> 00:11:02.370
Columnar databases tend to
be much more efficient at

191
00:11:02.370 --> 00:11:04.240
this type of data extraction operation.

192
00:11:06.055 --> 00:11:10.210
Key-value stores are very simple but
power ways of storing data.

193
00:11:10.210 --> 00:11:12.720
They store information
in very small pairs.

194
00:11:12.720 --> 00:11:15.160
Typically, a key and a value.

195
00:11:15.160 --> 00:11:17.740
This method of storing
data is very flexible

196
00:11:17.740 --> 00:11:22.570
as it doesn't require the extensive design
and structure of other data base types.

197
00:11:22.570 --> 00:11:24.390
Without getting into too much detail,

198
00:11:24.390 --> 00:11:27.690
it turns out that storing data
in this way is very efficient.

199
00:11:27.690 --> 00:11:29.110
Uses less memory, and

200
00:11:29.110 --> 00:11:33.700
can be used to achieve very high levels
of speed in certain types of operation.

201
00:11:33.700 --> 00:11:36.360
However, it also requires
more sophisticated

202
00:11:36.360 --> 00:11:38.390
programming to manipulate and
extract data.

203
00:11:40.250 --> 00:11:41.675
So let's recap.

204
00:11:41.675 --> 00:11:46.230
We've learnt about two broad types of
data storage, Data Files and Databases.

205
00:11:46.230 --> 00:11:50.660
We talked about file systems and specific
file formats like Delimited Text Files,

206
00:11:50.660 --> 00:11:55.010
XML Files, Log Files and
Application-specific Files.

207
00:11:55.010 --> 00:11:57.160
We introduce the idea of databases and

208
00:11:57.160 --> 00:12:01.500
covered different types of databases like
Relational Databases, Graph Databases,

209
00:12:01.500 --> 00:12:05.310
Document Stores, Columnar Databases and
Key-value Stores.

210
00:12:06.650 --> 00:12:10.310
As a data analyst, you almost certainly
encounter a number of these data storage

211
00:12:10.310 --> 00:12:13.180
mechanism both data files and databases.

212
00:12:13.180 --> 00:12:15.790
And you need to understand
how to work with them.

213
00:12:15.790 --> 00:12:18.450
Unfortunately, we can't cover
all of them in this course.

214
00:12:18.450 --> 00:12:22.560
But as we mentioned earlier, we will go
a bit deeper into relational databases.

215
00:12:22.560 --> 00:12:24.580
And in subsequent courses,
we'll use Excel and

216
00:12:24.580 --> 00:12:27.545
more advanced tools to actually
execute different types of analysis.