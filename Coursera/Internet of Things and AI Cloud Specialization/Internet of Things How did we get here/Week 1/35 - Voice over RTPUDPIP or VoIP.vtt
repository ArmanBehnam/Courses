WEBVTT

1
00:00:03.310 --> 00:00:05.388
What are some of the internet protocol?

2
00:00:05.388 --> 00:00:10.589
Is, actually,
you have the IP layer, above that,

3
00:00:10.589 --> 00:00:14.844
there is the UDP layer, and, above that,

4
00:00:14.844 --> 00:00:19.831
there is RTP,
real time transmission protocol.

5
00:00:20.930 --> 00:00:27.920
The reason to have this and
not TCP is when you are waiting for

6
00:00:27.920 --> 00:00:32.450
each packet to be acknowledged and
then have rechance missions,

7
00:00:32.450 --> 00:00:36.560
you just cannot have real time systems.

8
00:00:36.560 --> 00:00:41.479
So the thing about real time services

9
00:00:41.479 --> 00:00:46.270
is if you don't get the packets
at a certain amount of time,

10
00:00:46.270 --> 00:00:50.890
you basically drop it on the floor and
move on to the next thing.

11
00:00:50.890 --> 00:00:57.359
And a lot of the codecs that
compress wise and expand wise.

12
00:00:58.980 --> 00:01:07.100
They have some built-in mechanisms to
make the sound not very objectionable.

13
00:01:07.100 --> 00:01:11.150
So the UniP is much simpler than the TCP.

14
00:01:11.150 --> 00:01:16.640
You have the source port and the
destination port and you have a checksum

15
00:01:16.640 --> 00:01:22.640
on all of the data that
the UDP packet counted.

16
00:01:22.640 --> 00:01:27.760
So it's much smaller protocol
compared to TCP in that sense.

17
00:01:29.330 --> 00:01:36.300
And you have the real time transport
protocol that sits on top of UDP.

18
00:01:37.730 --> 00:01:42.087
The two points that you should
pay attention to in RTP is

19
00:01:42.087 --> 00:01:45.607
the sequence number.

20
00:01:45.607 --> 00:01:49.210
So this is real time data
every voice packet or

21
00:01:49.210 --> 00:01:53.750
every video packet gets
sequentially numbered so

22
00:01:53.750 --> 00:02:00.420
that if some of them are missing you
know which of them are actually lost,

23
00:02:00.420 --> 00:02:04.550
so the decoder, the receiver,
knows where there are gaps in the data.

24
00:02:07.490 --> 00:02:13.690
There is a time stamp information for
all the packets that she actually kept.

25
00:02:13.690 --> 00:02:18.710
This directly relates to the wall clock,
so that you can

26
00:02:18.710 --> 00:02:23.290
control the rate at which
you play back information,

27
00:02:23.290 --> 00:02:28.190
is it video or voice?

28
00:02:28.190 --> 00:02:33.940
So for certain fixed networks which

29
00:02:33.940 --> 00:02:39.630
we were mainly using that
looking at Wise examples.

30
00:02:39.630 --> 00:02:45.190
There is a codec that generates packets,
and

31
00:02:45.190 --> 00:02:49.500
it directly goes to the medium
access layer, MAC layer, and

32
00:02:49.500 --> 00:02:53.910
that goes to the Phy, which is the.

33
00:02:53.910 --> 00:02:59.012
The MAC and Phy are later GSM or

34
00:02:59.012 --> 00:03:03.814
amps that we will see in future

35
00:03:03.814 --> 00:03:08.490
modules on wireless technologies.

36
00:03:08.490 --> 00:03:11.520
But, the main point is, you get

37
00:03:11.520 --> 00:03:16.530
one packet every 20 milliseconds
that needs to be played back.

38
00:03:17.830 --> 00:03:21.470
If you look at the IP side,

39
00:03:21.470 --> 00:03:27.000
it goes through all these different
layers, including RTP, UDP,

40
00:03:27.000 --> 00:03:31.753
IP, and
because they could take different routes,

41
00:03:31.753 --> 00:03:38.715
there is a variable latency
in which you get packets.

42
00:03:38.715 --> 00:03:45.750
So number one, there is lots of
overhead in the data that you sent.

43
00:03:45.750 --> 00:03:51.433
This is perfectly fine in
a wired line Internet but for

44
00:03:51.433 --> 00:03:57.000
VOIP or wireless access,
it's got lots of issues.

45
00:03:57.000 --> 00:04:04.917
That's the reason why the voice
in cell phones is still in 3G and

46
00:04:04.917 --> 00:04:09.902
not 4G still circuit switched the other

47
00:04:09.902 --> 00:04:14.165
services are packaged switched.

48
00:04:14.165 --> 00:04:15.884
And because of the latency and

49
00:04:15.884 --> 00:04:20.091
the [INAUDIBLE] which you need to buffer
them up for much longer duration.

50
00:04:20.091 --> 00:04:22.560
And drain the buffer at a constant rate.

51
00:04:23.890 --> 00:04:29.360
The other problem is if you
send very large packets so

52
00:04:29.360 --> 00:04:33.850
that you can amortize the header
over much longer data payload.

53
00:04:33.850 --> 00:04:38.370
If one small chunk is lost,
then you have lost the whole data.

54
00:04:38.370 --> 00:04:40.669
And this is called loss of good code.

55
00:04:41.900 --> 00:04:44.080
Even though when you have good throughput.