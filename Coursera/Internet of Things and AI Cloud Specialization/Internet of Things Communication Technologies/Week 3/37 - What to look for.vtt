WEBVTT

1
00:00:01.410 --> 00:00:06.360
So as we go about compressing
source signals willy nilly,

2
00:00:06.360 --> 00:00:11.900
if we understand the price to be paid and
the trade offs that are involved,

3
00:00:11.900 --> 00:00:15.960
we get to pick the right tool for
the right job.

4
00:00:15.960 --> 00:00:22.810
So I want to spend a couple of minutes
here to get you acquainted with us.

5
00:00:22.810 --> 00:00:27.710
The foremost is
the compression efficiency and

6
00:00:27.710 --> 00:00:32.330
at what quality,
because these two are not always linear

7
00:00:33.350 --> 00:00:37.510
depending on the compression
technique that you use.

8
00:00:37.510 --> 00:00:42.646
The real trade off is bandwidth
that you need [COUGH] versus

9
00:00:42.646 --> 00:00:47.675
the quality of the signal that
needs to be rendered, and

10
00:00:47.675 --> 00:00:53.044
this is heavily,
heavily dependent on your application.

11
00:00:53.044 --> 00:00:58.984
For real time communication like y,
you want very,

12
00:00:58.984 --> 00:01:06.000
very low latency,
typically ten to 30 milliseconds.

13
00:01:06.000 --> 00:01:11.000
And don't forget that the rest of
the communication link acts as much as

14
00:01:11.000 --> 00:01:16.560
100 to 200 milliseconds latency
depending on the link quality,

15
00:01:17.640 --> 00:01:21.290
congestion, number of hubs, etcetera.

16
00:01:21.290 --> 00:01:26.930
So for wireless communications,
real time communications, 100 milliseconds

17
00:01:26.930 --> 00:01:31.920
is about the border, after that
you're really asking for trouble.

18
00:01:31.920 --> 00:01:38.240
And around 200 milliseconds you will
find huge silences on the line,

19
00:01:38.240 --> 00:01:42.720
and then both of you start speaking
at the same time because we are not

20
00:01:42.720 --> 00:01:47.570
really used to turn taking with so
much long latency.

21
00:01:49.180 --> 00:01:55.363
And next to the algorithm latency, the
error resiliency is very, very important.

22
00:01:55.363 --> 00:02:00.464
All channels,
especially wireless, have losses,

23
00:02:00.464 --> 00:02:05.290
and when the data is heavily compressed,
every bit that

24
00:02:05.290 --> 00:02:11.000
is remaining is so much more valuable,
so error resiliency

25
00:02:11.000 --> 00:02:16.330
is very important if you want to be
able to recover from the errors.

26
00:02:16.330 --> 00:02:21.550
For some signals, like for voice,
you can do pretty nifty things like

27
00:02:22.680 --> 00:02:27.390
Peter's Pictel Packet Loss Concealment
if you know the signal before and

28
00:02:27.390 --> 00:02:32.320
the signal after, you can interpolate and
do a good job for

29
00:02:32.320 --> 00:02:36.370
one to two frames of lost packets.

30
00:02:38.210 --> 00:02:44.080
The computational complexity used to be
a really big criteria a few years ago,

31
00:02:44.080 --> 00:02:49.610
but given the advances in silicon
technology and the DSPs that you find

32
00:02:49.610 --> 00:02:56.080
in most mobile platforms, including
Snapdragon, I think this is a wash.

33
00:02:56.080 --> 00:03:02.040
Still, if you have Apache powered sensor
and are doing a lot of processing,

34
00:03:02.040 --> 00:03:07.210
you do need to pay attention,
but probably not for wide calls.