WEBVTT

1
00:00:02.438 --> 00:00:03.590
Welcome back.

2
00:00:03.590 --> 00:00:07.810
Now, let's take a look
at video processing.

3
00:00:07.810 --> 00:00:10.530
This is the block diagram
that we were looking at.

4
00:00:11.960 --> 00:00:16.770
The main workhorse of video codecs for
bit rate reduction [COUGH] is

5
00:00:16.770 --> 00:00:20.888
motion estimation, and
motion prediction at the sender side.

6
00:00:20.888 --> 00:00:25.830
And those bits are sent along
with the texture information.

7
00:00:25.830 --> 00:00:29.700
And at the receiver,
we do motion compensation.

8
00:00:29.700 --> 00:00:35.210
I do not show that in this block
diagram and we build on top of

9
00:00:35.210 --> 00:00:42.660
the still image compression JPEG texture
coding aspects that we just talked about,

10
00:00:42.660 --> 00:00:47.075
and on top of that,
we add motion processing.

11
00:00:47.075 --> 00:00:54.335
So this is how motion estimation and
compensation works.

12
00:00:54.335 --> 00:00:58.760
[COUGH] We use the current frame,
when we are working on the current frame,

13
00:00:58.760 --> 00:01:03.610
we use one or
more of the neighboring frames.

14
00:01:03.610 --> 00:01:08.110
It can be previous frame or
it can be a future frame,

15
00:01:08.110 --> 00:01:12.370
which of course introduces some delay.

16
00:01:12.370 --> 00:01:16.960
And these are called the reference frames.

17
00:01:16.960 --> 00:01:22.438
And we estimate a pixel or
groups of pixels that have moved

18
00:01:22.438 --> 00:01:27.070
with respect to the reference frame and

19
00:01:27.070 --> 00:01:30.340
once we know which groups
of pixels have moved,

20
00:01:30.340 --> 00:01:35.500
we get a difference in the current
frame that we are working.

21
00:01:35.500 --> 00:01:39.760
And we actually work
only on the differences.

22
00:01:39.760 --> 00:01:44.912
That's why this is called
DPCM motion estimation and

23
00:01:44.912 --> 00:01:48.697
differential pulse code modulation.

24
00:01:48.697 --> 00:01:54.512
We use DCT as the transform and
then the quantization and

25
00:01:54.512 --> 00:01:58.842
the run length encoding and the Huffman,

26
00:01:58.842 --> 00:02:03.964
they are exactly the same
as what we used in JPEG.

27
00:02:03.964 --> 00:02:11.260
[COUGH] So
this leads to the concept of the,

28
00:02:11.260 --> 00:02:17.110
what we call, group of pictures GOP and

29
00:02:17.110 --> 00:02:21.830
when the content is completely new,
when we get a brand new frame

30
00:02:21.830 --> 00:02:26.710
which has no correlation with
either past or future frames.

31
00:02:26.710 --> 00:02:33.110
We called it as an intra-frame that
can be decoded completely on its own.

32
00:02:33.110 --> 00:02:35.326
This is like JPEG.

33
00:02:35.326 --> 00:02:43.510
The predicted frames use only the previous
frames to compute the current frame and

34
00:02:44.630 --> 00:02:49.840
the differences are encoded and sent.

35
00:02:49.840 --> 00:02:54.330
This is like ADPCM that we
saw in speech and audio.

36
00:02:56.220 --> 00:02:59.930
You can also use bilateral prediction,

37
00:02:59.930 --> 00:03:04.860
prediction from future and
back and preview and past.

38
00:03:04.860 --> 00:03:06.602
These are called B-Frames.

39
00:03:06.602 --> 00:03:10.595
So till you get another I-Frame,

40
00:03:10.595 --> 00:03:15.829
you're basically building off the previous

41
00:03:15.829 --> 00:03:20.520
I-frame and the predicted delta.

42
00:03:20.520 --> 00:03:25.950
So there is some additional latency
involved between the I-frame.

43
00:03:25.950 --> 00:03:28.765
So if you get a nearer
in the transmission,

44
00:03:28.765 --> 00:03:33.600
[COUGH] you would not
recover it very easily.

45
00:03:33.600 --> 00:03:34.800
I'll get back to that in a minute.

46
00:03:34.800 --> 00:03:40.830
The other important way,

47
00:03:40.830 --> 00:03:47.650
the video coding can get
very high compression ratios

48
00:03:47.650 --> 00:03:53.380
even for the texture and also its so
factor on motion aspects is.

49
00:03:53.380 --> 00:03:59.433
Instead of just looking at 8 by 8
blocks wow we look at 16 by 16,

50
00:03:59.433 --> 00:04:02.857
4 by 4 and the combination of these.

51
00:04:02.857 --> 00:04:08.140
And all this acts a lot of complexity

52
00:04:08.140 --> 00:04:11.970
at the encoder and
slightly more complexity at the decoder.

53
00:04:11.970 --> 00:04:16.878
But it's really the encoder that
gets bit [COUGH] very badly.

54
00:04:16.878 --> 00:04:20.740
But you do get much bigger
data rate reductions.

55
00:04:21.880 --> 00:04:26.960
So as I was saying,
one of the weak links of getting all this

56
00:04:26.960 --> 00:04:31.628
compression and
sucking away all the redundancy is,

57
00:04:31.628 --> 00:04:36.730
even if you have a slight error
between the two I-Frames.

58
00:04:36.730 --> 00:04:41.398
The prediction loop for
the P-Frames and the B-Frames

59
00:04:41.398 --> 00:04:46.374
between the sender and
the receiver is completely broken.

60
00:04:46.374 --> 00:04:51.220
They're not in sync anymore.

61
00:04:51.220 --> 00:04:54.835
So the error stops building up.

62
00:04:54.835 --> 00:05:00.860
Till you correct it with an I-Frame or
some other mechanism.

63
00:05:00.860 --> 00:05:08.150
And the visual quality can goes out very,
very fast, till you manage to synchronize

64
00:05:08.150 --> 00:05:13.215
the prediction loop at the receiver
with that of the sender.

65
00:05:13.215 --> 00:05:17.494
[COUGH] Unfortunately the MPEG and

66
00:05:17.494 --> 00:05:22.077
ITU standards that define MPEG 4,

67
00:05:22.077 --> 00:05:25.454
H.264, H.265.

68
00:05:25.454 --> 00:05:31.492
[COUGH] excuse me,
this specified only the big stream and

69
00:05:31.492 --> 00:05:35.540
the operation of the receiver.

70
00:05:35.540 --> 00:05:40.065
So the encoder is free to do
whatever they want as long as it is

71
00:05:40.065 --> 00:05:43.330
generating compliant bit streams.

72
00:05:43.330 --> 00:05:49.637
This is slightly different from real time
communication standards such as in 3GPP,

73
00:05:49.637 --> 00:05:54.107
in 3GPP2, very unique to define
the encoder operation and

74
00:05:54.107 --> 00:05:58.430
the decoder operation and
the bits completely.

75
00:05:58.430 --> 00:06:03.562
So, what happens is,
if you do not have other mechanisms,

76
00:06:03.562 --> 00:06:10.260
this is a simulation in a cellular
network with pedestrian video model.

77
00:06:10.260 --> 00:06:14.700
You can see the quality,
the error occurs at frame number 88.

78
00:06:14.700 --> 00:06:17.570
And from that time onwards, at 98 and 123,

79
00:06:17.570 --> 00:06:23.760
you can see significant
degradations in the video quality.

80
00:06:23.760 --> 00:06:27.250
I'm sure you have seen this on IPTV and

81
00:06:27.250 --> 00:06:31.510
video streaming also when
the channel is not good.

82
00:06:31.510 --> 00:06:36.260
Other than that you do get
significant reductions

83
00:06:36.260 --> 00:06:40.630
in the data rate compared to
what you could do before.