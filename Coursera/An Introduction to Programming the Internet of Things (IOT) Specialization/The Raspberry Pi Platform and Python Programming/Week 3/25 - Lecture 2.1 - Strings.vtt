WEBVTT

1
00:00:00.000 --> 00:00:10.000
[MUSIC]

2
00:00:11.605 --> 00:00:15.520
Strings are an important
data type inside Python.

3
00:00:15.520 --> 00:00:18.640
Strings are basically just a sequence
of characters and closing quotes.

4
00:00:18.640 --> 00:00:21.760
So here we have Hello,
world is enclosed in quotes.

5
00:00:21.760 --> 00:00:24.730
Notice that in the case I'm using
single quotes to enclose the string.

6
00:00:24.730 --> 00:00:26.040
I could use double quotes.

7
00:00:26.040 --> 00:00:26.890
It doesn't matter.

8
00:00:26.890 --> 00:00:28.480
You can use either one.

9
00:00:28.480 --> 00:00:32.830
So a string is just a sequence
of characters and you know,

10
00:00:32.830 --> 00:00:35.270
it could be assigned to
a variable just like anything.

11
00:00:35.270 --> 00:00:37.360
So you could say X equals hello world or
something like that.

12
00:00:37.360 --> 00:00:39.189
And that would work.

13
00:00:39.189 --> 00:00:43.650
It can be manipulated so you can do
things to it using string operators and

14
00:00:43.650 --> 00:00:44.467
functions.

15
00:00:44.467 --> 00:00:47.674
And we'll talk about some of
the most common string operators and

16
00:00:47.674 --> 00:00:52.365
functions that you use to access certain
parts of the string, things like this.

17
00:00:52.365 --> 00:00:53.905
So a small example.

18
00:00:53.905 --> 00:00:54.755
You can say hello.

19
00:00:54.755 --> 00:00:58.065
Just type in 'Hello, World' at the prompt,
and it just prints it back to you.

20
00:00:58.065 --> 00:01:01.961
You could set variables equal to strings,
so s = 'still' and

21
00:01:01.961 --> 00:01:04.400
t = 'life', and that's fine to do.

22
00:01:06.510 --> 00:01:09.400
Now, here are some string operators,
some of the more common operators.

23
00:01:10.570 --> 00:01:13.100
Let's go through these one at a time.

24
00:01:13.100 --> 00:01:15.660
So let's take the first operator, x in s.

25
00:01:15.660 --> 00:01:19.540
Now in this case, x and
s are both strings.

26
00:01:19.540 --> 00:01:23.945
And x in s tests if x is a substring of s.

27
00:01:23.945 --> 00:01:25.570
So it's a Boolean operator.

28
00:01:25.570 --> 00:01:31.010
It returns a true if x is,
can be found within s, a bigger string s.

29
00:01:31.010 --> 00:01:33.020
X not in s is obviously the opposite,
right?

30
00:01:33.020 --> 00:01:37.420
It returns true if x cannot be
found as a substring within s.

31
00:01:37.420 --> 00:01:38.930
S + t is concatenation.

32
00:01:38.930 --> 00:01:40.800
So you take two, s and

33
00:01:40.800 --> 00:01:45.060
t are two strings, concatenation basically
means putting the two strings together.

34
00:01:45.060 --> 00:01:47.898
So just gluing them together
as one bigger string.

35
00:01:47.898 --> 00:01:50.040
So s + t returns a string,

36
00:01:51.090 --> 00:01:54.860
a new string which is the concatenation
of the two individual strings.

37
00:01:56.240 --> 00:01:59.230
S x n and n x s,
either importer doesn't matter.

38
00:01:59.230 --> 00:02:02.530
In this case s is a string and
it's just some integer.

39
00:02:03.560 --> 00:02:07.590
And what that does is it
concatenate s to itself n times.

40
00:02:07.590 --> 00:02:11.260
So if you say s times two, it takes s,
whatever that string is, and

41
00:02:11.260 --> 00:02:12.710
repeats it twice.

42
00:02:12.710 --> 00:02:15.330
It concatenates it to itself two times.

43
00:02:15.330 --> 00:02:18.990
And then if you say s times three,
it copies it three times and so on.

44
00:02:20.140 --> 00:02:24.640
All right now s[i],
that's the index operation.

45
00:02:24.640 --> 00:02:25.920
And we'll talk about this, but

46
00:02:25.920 --> 00:02:28.950
basically that's how you access
an individual character in a string.

47
00:02:28.950 --> 00:02:33.564
So if s is a string, then i is some
integer, s of zero, s bracket zero,

48
00:02:33.564 --> 00:02:36.710
is the first character in that string.

49
00:02:36.710 --> 00:02:39.810
And then s bracket one is the second
character in the string, and so on.

50
00:02:39.810 --> 00:02:44.550
So you can access individual characters
inside a string using this index operator.

51
00:02:44.550 --> 00:02:48.880
And len, with s for s is a string, that
just tells you the length of the string,

52
00:02:48.880 --> 00:02:52.480
you often need to know that in terms
of the integer, which is the length.

53
00:02:52.480 --> 00:02:57.540
So these are very common operators, let's
look at some of these operators in action.

54
00:02:57.540 --> 00:03:01.950
So here we have a just a, so we start
off with Hello, World prints it out.

55
00:03:01.950 --> 00:03:04.110
S is equal to still, t is equal to life.

56
00:03:04.110 --> 00:03:06.460
And then after that we're
using some Boolean operators.

57
00:03:06.460 --> 00:03:09.760
Actually, in addition to some
string operators I described above,

58
00:03:09.760 --> 00:03:13.300
you can use Boolean operators,
comparison operators.

59
00:03:13.300 --> 00:03:16.957
So for instance,
s == 'still', all right, and

60
00:03:16.957 --> 00:03:19.960
s is equal to still, so that returns true.

61
00:03:21.000 --> 00:03:24.760
S not equal to t, that also returns
true because s is still, t is life.

62
00:03:24.760 --> 00:03:26.880
They're not equal, so returns true.

63
00:03:26.880 --> 00:03:28.700
S less than t and greater than t.

64
00:03:28.700 --> 00:03:32.440
That's basically alphanumerical order,
and since s is earlier,

65
00:03:32.440 --> 00:03:34.710
s is still and t is life, right?

66
00:03:34.710 --> 00:03:38.380
So life is earlier in
the alphabet than still, so

67
00:03:38.380 --> 00:03:41.350
life is actually less than
still by that ordering.

68
00:03:41.350 --> 00:03:45.662
So when you say is s less than t it's
false and t less than s is true.

69
00:03:47.485 --> 00:03:50.189
So, let's go through some
of those string operators.

70
00:03:51.300 --> 00:03:54.680
Remember, s is equal to still,
t is equal to life in our example, so

71
00:03:54.680 --> 00:03:57.460
if I say s + t,
it just makes a new string,

72
00:03:57.460 --> 00:04:00.560
stilllife, glues them both together,
concatenates them together.

73
00:04:00.560 --> 00:04:05.330
Now, in the next line, I saw s +, and then
in quotes I have a single blank space, so

74
00:04:05.330 --> 00:04:08.740
s + blank space + t, so
I'm concatenating three things.

75
00:04:08.740 --> 00:04:11.350
Still, and then a blank space, and then t.

76
00:04:11.350 --> 00:04:14.830
So in the end I get,
still life, as the new string.

77
00:04:14.830 --> 00:04:17.520
The last one I say 5 * x.

78
00:04:17.520 --> 00:04:19.480
I just take the word still,
which is s, and

79
00:04:19.480 --> 00:04:24.560
repeat it five times and that's it,
concatenate it five times.

80
00:04:24.560 --> 00:04:26.350
So those are some operators.

81
00:04:26.350 --> 00:04:28.695
Then here's another example
of the concatenation.

82
00:04:28.695 --> 00:04:29.954
The multiple concatenations.

83
00:04:29.954 --> 00:04:32.549
So 20 * "_".

84
00:04:32.549 --> 00:04:35.735
I have an underscore in single quotes,
so it just repeats 20 of them and

85
00:04:35.735 --> 00:04:37.630
gives me a big string of 20 underscores.

86
00:04:38.690 --> 00:04:42.397
Now the next one i in s is true.

87
00:04:42.397 --> 00:04:46.224
So it's looking at the string,
a very short string, i, is that inside s?

88
00:04:46.224 --> 00:04:48.398
Now s is the word still, is i in there?

89
00:04:48.398 --> 00:04:51.636
Yes, there is an i in there,
so it returns true.

90
00:04:51.636 --> 00:04:53.018
O in t.

91
00:04:53.018 --> 00:04:57.994
So o, the letter o is not in the word
life, so o in t returns false.

92
00:04:57.994 --> 00:05:02.571
Li in t true because li is
a substring of life, and

93
00:05:02.571 --> 00:05:06.379
length of t is 4 because life is 4 long.

94
00:05:06.379 --> 00:05:08.960
And there's the indexing operator.

95
00:05:08.960 --> 00:05:14.188
Indexing operator basically takes
a string, in this case apple because apple

96
00:05:14.188 --> 00:05:19.648
is a string, and you could pass it inside
the brackets, you pass an index number,

97
00:05:19.648 --> 00:05:25.190
an integer which is the value, the number
of the character that you're looking for

98
00:05:25.190 --> 00:05:28.070
inside the string and it'll return that.

99
00:05:28.070 --> 00:05:30.252
So, s|0|, it starts at 0.

100
00:05:30.252 --> 00:05:30.971
It starts counting at 0.

101
00:05:30.971 --> 00:05:34.039
So, s |0| gives me the first
character which is a capital A.

102
00:05:34.039 --> 00:05:37.150
S|1| gives me the second
character which is lower case p.

103
00:05:37.150 --> 00:05:37.650
And so on.

104
00:05:39.150 --> 00:05:42.570
It takes the index as the argument and
indices start at zero, remember that.

105
00:05:42.570 --> 00:05:45.260
That one off error,
sometimes you think it starts at one.

106
00:05:45.260 --> 00:05:49.000
Remember in computer science
we're always start at zero.

107
00:05:49.000 --> 00:05:51.880
And you can identify individual
characters inside a string, or

108
00:05:51.880 --> 00:05:54.528
refer to them and
use them in any way you want in the code.

109
00:05:54.528 --> 00:05:55.531
Thank you.

110
00:05:55.531 --> 00:06:04.599
[MUSIC]