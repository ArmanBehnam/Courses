WEBVTT

1
00:00:00.260 --> 00:00:02.880
So, we're going to do
a little comparison of

2
00:00:02.880 --> 00:00:05.600
the Raspberry Pi 3 B+
vs the Arduino,

3
00:00:05.600 --> 00:00:06.735
say Arduino Uno,

4
00:00:06.735 --> 00:00:09.890
generally what we used
in the last class.

5
00:00:09.890 --> 00:00:11.640
So, you can have
some idea when you

6
00:00:11.640 --> 00:00:14.020
should use one, when you
should use the other.

7
00:00:14.450 --> 00:00:18.510
So, the Raspberry Pi
processor is faster.

8
00:00:18.510 --> 00:00:21.300
It's 1.4 gigahertz
as compared to,

9
00:00:21.300 --> 00:00:23.760
say 16 megahertz in the Arduino.

10
00:00:23.760 --> 00:00:26.625
So, that's a lot faster,
it would sound like.

11
00:00:26.625 --> 00:00:29.070
But remember, that
the Raspberry Pi is

12
00:00:29.070 --> 00:00:31.650
running an operating system
and that slows things down.

13
00:00:31.650 --> 00:00:33.030
Right? Because
the operating system is

14
00:00:33.030 --> 00:00:35.115
a big block of code that
has to be executed.

15
00:00:35.115 --> 00:00:36.690
Also there are other things
slow things down.

16
00:00:36.690 --> 00:00:38.235
When you write in
the Raspberry Pi,

17
00:00:38.235 --> 00:00:41.910
when you're controlling
the PNG usually using Python,

18
00:00:41.910 --> 00:00:43.580
which means you got on
a Python interpreter and

19
00:00:43.580 --> 00:00:45.470
there also slowing things down.

20
00:00:45.470 --> 00:00:48.980
So, it's faster but is
deceptive that speed up.

21
00:00:48.980 --> 00:00:51.640
It's not as good as
you would think.

22
00:00:51.640 --> 00:00:54.930
The Raspberry Pi, the new one is

23
00:00:54.930 --> 00:00:59.955
a 64-bit processor versus
eight bits for the Arduino.

24
00:00:59.955 --> 00:01:02.330
So, that means numbers
are much bigger.

25
00:01:02.330 --> 00:01:04.340
You get a lot better accuracy
with the Raspberry Pi.

26
00:01:04.340 --> 00:01:06.980
So, if you need accuracy
in your numbers,

27
00:01:06.980 --> 00:01:08.210
Raspberry Pi is
really the way to go,

28
00:01:08.210 --> 00:01:09.410
because eight bits isn't

29
00:01:09.410 --> 00:01:11.375
generally sufficient
for accurate numbers.

30
00:01:11.375 --> 00:01:12.950
If you just doing control,

31
00:01:12.950 --> 00:01:14.870
then maybe you don't need
accuracy in the numbers,

32
00:01:14.870 --> 00:01:16.220
then Arduino is fine.

33
00:01:16.220 --> 00:01:18.230
But Raspberry Pi, it really

34
00:01:18.230 --> 00:01:20.720
does beat it out in
the accuracy area.

35
00:01:20.720 --> 00:01:22.670
You can have
a bigger address space,

36
00:01:22.670 --> 00:01:24.590
although, it doesn't use
that much address space,

37
00:01:24.590 --> 00:01:26.580
but you can have a lot
more memory addresses, say,

38
00:01:26.580 --> 00:01:28.265
or whatever type of
addresses you want to have

39
00:01:28.265 --> 00:01:31.130
because you've got
16 bits represented with.

40
00:01:31.130 --> 00:01:34.030
Raspberry Pi has more memory.

41
00:01:34.030 --> 00:01:37.125
So, Arduino has 32 K flash,

42
00:01:37.125 --> 00:01:39.570
2 K SRAM, 1 K EEPROM.

43
00:01:39.570 --> 00:01:41.970
Raspberry Pi has
got a one gig SRAM,

44
00:01:41.970 --> 00:01:43.080
and a micro SD, so,

45
00:01:43.080 --> 00:01:46.230
you can have tons of flash
as much as you want,

46
00:01:46.230 --> 00:01:49.160
and tons of non-volatile memory
as much as you can put in

47
00:01:49.160 --> 00:01:52.785
a micro SD which is a lot
more than 32 K. So,

48
00:01:52.785 --> 00:01:55.710
Raspberry Pi seems good
in this way, it's good.

49
00:01:55.710 --> 00:02:00.585
It is good. Raspberry Pi has
lower IO voltage levels.

50
00:02:00.585 --> 00:02:02.360
So, this is something

51
00:02:02.360 --> 00:02:04.355
to remember when you're
making a system.

52
00:02:04.355 --> 00:02:05.930
When you make a system, you
going to make sure that

53
00:02:05.930 --> 00:02:08.225
the voltage levels are
compatible across the system.

54
00:02:08.225 --> 00:02:10.490
So, say you've got
the micro-controller and is

55
00:02:10.490 --> 00:02:12.260
wired to several different
integrated circuits,

56
00:02:12.260 --> 00:02:14.645
several sensors,
actuators, and so on,

57
00:02:14.645 --> 00:02:16.925
these things run at
a certain voltage level

58
00:02:16.925 --> 00:02:18.275
and they should all be the same.

59
00:02:18.275 --> 00:02:19.850
So, all five volts,

60
00:02:19.850 --> 00:02:24.125
all 3.3, and generally 3.3
volts is good, reduces power.

61
00:02:24.125 --> 00:02:28.260
Right? But, it can be causing

62
00:02:28.260 --> 00:02:30.000
compatibility depending
on your sensors and

63
00:02:30.000 --> 00:02:31.830
actuators and
other integrated circuits

64
00:02:31.830 --> 00:02:32.570
that you're talking to.

65
00:02:32.570 --> 00:02:34.550
So, you have to
have voltage level

66
00:02:34.550 --> 00:02:37.505
switching components
between things.

67
00:02:37.505 --> 00:02:40.130
So, say you're using
an Arduino is running at

68
00:02:40.130 --> 00:02:42.890
five volts but
the sensor is 3.3 volts,

69
00:02:42.890 --> 00:02:43.970
you might have to switch

70
00:02:43.970 --> 00:02:46.565
the voltage levels
somehow, and vice versa.

71
00:02:46.565 --> 00:02:48.680
If you've got a five volt sensor

72
00:02:48.680 --> 00:02:50.115
connected to a Raspberry Pi,

73
00:02:50.115 --> 00:02:51.810
you have to switch
the voltage levels,

74
00:02:51.810 --> 00:02:53.750
and there's hardware
you can use to do that.

75
00:02:53.750 --> 00:02:55.465
So, just be aware of that.

76
00:02:55.465 --> 00:02:57.735
Now, one of the thing I'd
like to mention here,

77
00:02:57.735 --> 00:02:59.630
is that the Raspberry Pi,

78
00:02:59.630 --> 00:03:01.010
this isn't sort of
a document I think,

79
00:03:01.010 --> 00:03:02.480
but this is something
that I've noticed.

80
00:03:02.480 --> 00:03:04.475
It is sensitive to power.

81
00:03:04.475 --> 00:03:06.335
Okay. When I say sensitive,

82
00:03:06.335 --> 00:03:07.580
if you pull down,

83
00:03:07.580 --> 00:03:08.600
draw too much power,

84
00:03:08.600 --> 00:03:09.830
if it draws too much power,

85
00:03:09.830 --> 00:03:11.540
if somebody draws
too much power from it,

86
00:03:11.540 --> 00:03:13.820
it'll just reboot and mess it up.

87
00:03:13.820 --> 00:03:16.355
Okay. Reboot will sometimes
mess up the flash,

88
00:03:16.355 --> 00:03:18.665
mess up the SDRAM, I've had
that happen several times.

89
00:03:18.665 --> 00:03:20.060
So, what I mean is, I've had

90
00:03:20.060 --> 00:03:22.180
many times where I
take a Raspberry Pi,

91
00:03:22.180 --> 00:03:24.135
and I powered from USB.

92
00:03:24.135 --> 00:03:25.635
Maybe it's not getting that much,

93
00:03:25.635 --> 00:03:27.165
depending on the USB jack,

94
00:03:27.165 --> 00:03:28.460
you can only get

95
00:03:28.460 --> 00:03:30.410
a certain amount of
current from some jacks.

96
00:03:30.410 --> 00:03:32.555
Right? So then, if I plug into,

97
00:03:32.555 --> 00:03:34.895
it'll just run the plane
Raspberry Pi fine.

98
00:03:34.895 --> 00:03:37.340
But when I plug
into the USB port,

99
00:03:37.340 --> 00:03:39.625
something that sucks
a lot of power,

100
00:03:39.625 --> 00:03:41.930
then the Raspberry Pi
has to supply power to

101
00:03:41.930 --> 00:03:43.400
that and it's not

102
00:03:43.400 --> 00:03:45.240
getting sufficient power
from the USB port,

103
00:03:45.240 --> 00:03:47.520
and it'll just reboot or
something right in the middle.

104
00:03:47.520 --> 00:03:49.535
That has happened
to me many times

105
00:03:49.535 --> 00:03:50.750
and I've had to re-install,

106
00:03:50.750 --> 00:03:52.550
I don't know why this is,
but I've had to re-install

107
00:03:52.550 --> 00:03:55.830
the operating system when
I drawn too much power.

108
00:03:55.830 --> 00:03:57.650
It's sensitive to that, Arduinos

109
00:03:57.650 --> 00:03:58.670
aren't sensitive to anything.

110
00:03:58.670 --> 00:04:00.980
So, when I just have
control operations,

111
00:04:00.980 --> 00:04:04.055
I will use an Arduino every
time over Raspberry Pi.

112
00:04:04.055 --> 00:04:08.320
But, the best thing about
Raspberry Pi to me,

113
00:04:08.320 --> 00:04:10.520
is that it has
an operating system on it.

114
00:04:10.520 --> 00:04:12.500
Best and worse but,
let's say best.

115
00:04:12.500 --> 00:04:14.480
So, when I need an operating
system I have to go with

116
00:04:14.480 --> 00:04:16.730
Raspberry Pi because
Arduino won't do it.

117
00:04:16.730 --> 00:04:19.235
So, Raspberry Pi can support
an operating system.

118
00:04:19.235 --> 00:04:21.020
Now, we'll talk a

119
00:04:21.020 --> 00:04:22.835
little bit more about
operating systems.

120
00:04:22.835 --> 00:04:24.860
Everybody knows what
an operating system

121
00:04:24.860 --> 00:04:26.780
is or has some
intuition about it.

122
00:04:26.780 --> 00:04:31.490
Right? Windows 10, Mac OSX,

123
00:04:31.490 --> 00:04:33.799
you know, these are
operating systems,

124
00:04:33.799 --> 00:04:36.675
Linux, the best, Linux.

125
00:04:36.675 --> 00:04:38.370
These are operating systems.

126
00:04:38.370 --> 00:04:40.670
These things, on any desktop or

127
00:04:40.670 --> 00:04:43.330
laptop is always running
an operating system.

128
00:04:43.330 --> 00:04:45.650
So, when some program is

129
00:04:45.650 --> 00:04:47.780
executing on your laptop
or your desktop,

130
00:04:47.780 --> 00:04:49.590
it's not just the
program executing,

131
00:04:49.590 --> 00:04:51.650
it is also the operating
system itself.

132
00:04:51.650 --> 00:04:52.880
The operating system
is a block of

133
00:04:52.880 --> 00:04:55.300
code and that is executing too.

134
00:04:55.300 --> 00:04:58.400
Now, this is bad because
it slows things down.

135
00:04:58.400 --> 00:05:00.410
You're not just executing
your simple code,

136
00:05:00.410 --> 00:05:02.690
maybe you want a little
simple hello world code.

137
00:05:02.690 --> 00:05:04.640
Right? But it's also got to
run the operating system and

138
00:05:04.640 --> 00:05:06.830
its libraries and all
that junk slows it down.

139
00:05:06.830 --> 00:05:09.470
But it's good because
the operating system handles

140
00:05:09.470 --> 00:05:10.850
a lot of things that you

141
00:05:10.850 --> 00:05:12.425
don't want to handle
as a programmer.

142
00:05:12.425 --> 00:05:15.180
Okay. It gives you these
libraries, and the system calls.

143
00:05:15.180 --> 00:05:17.320
These are library
functions make that do

144
00:05:17.320 --> 00:05:20.215
things that simplify your life.

145
00:05:20.215 --> 00:05:23.700
So, you don't have to worry
about all the details.

146
00:05:24.680 --> 00:05:26.820
So, if you look at these two,

147
00:05:26.820 --> 00:05:28.350
I have these two
little flowcharts.

148
00:05:28.350 --> 00:05:30.430
The left side is the Arduino,

149
00:05:30.430 --> 00:05:33.450
the right side is
the Raspberry Pi,

150
00:05:33.450 --> 00:05:35.150
or something with
an operating system.

151
00:05:35.150 --> 00:05:36.590
The left side, there's

152
00:05:36.590 --> 00:05:38.615
an application that
you wrote in say C,

153
00:05:38.615 --> 00:05:41.210
you compile it, and
that compiled code

154
00:05:41.210 --> 00:05:42.680
runs directly on
the micro-controller

155
00:05:42.680 --> 00:05:44.090
and there's nothing else.

156
00:05:44.090 --> 00:05:46.220
It is your compiled code

157
00:05:46.220 --> 00:05:49.180
running right on
the micro-controller. The end.

158
00:05:49.180 --> 00:05:51.075
With an operating system,

159
00:05:51.075 --> 00:05:52.860
there's your
application, you have to

160
00:05:52.860 --> 00:05:55.005
compile code from that,
but it doesn't just run,

161
00:05:55.005 --> 00:05:56.490
it calls library functions,

162
00:05:56.490 --> 00:05:57.675
we call system calls,

163
00:05:57.675 --> 00:06:00.780
which eventually acts as
the micro-controller features.

164
00:06:00.780 --> 00:06:02.410
All that stuff in the middle is

165
00:06:02.410 --> 00:06:04.180
all basically operating system.

166
00:06:04.180 --> 00:06:05.785
Now, this is a very simplified

167
00:06:05.785 --> 00:06:07.075
version of an operating system.

168
00:06:07.075 --> 00:06:11.200
This is the idea,
the operating system code,

169
00:06:11.200 --> 00:06:13.630
it enables a lot of things.

170
00:06:13.630 --> 00:06:16.080
For instance, say you want

171
00:06:16.080 --> 00:06:19.790
to print something on
an HDMI monitor, okay.

172
00:06:19.790 --> 00:06:22.030
The operating system
will provide you with

173
00:06:22.030 --> 00:06:24.370
library functions to deal
with that and drivers,

174
00:06:24.370 --> 00:06:25.720
and it is very easy,

175
00:06:25.720 --> 00:06:28.045
type 'print' and it'll just
appear on the HDMI monitor.

176
00:06:28.045 --> 00:06:30.130
Now, in Arduino you
can't just do that.

177
00:06:30.130 --> 00:06:32.560
How do you connect
to an HDMI Monitor?

178
00:06:32.560 --> 00:06:34.080
Maybe there's a shield for it,

179
00:06:34.080 --> 00:06:35.950
or some extra hardware
you can buy,

180
00:06:35.950 --> 00:06:38.185
something like that, but it's
a more complicated thing.

181
00:06:38.185 --> 00:06:39.485
With an operating
system, you just

182
00:06:39.485 --> 00:06:41.080
do it because it's all built in.

183
00:06:41.080 --> 00:06:42.890
So, operating systems are very

184
00:06:42.890 --> 00:06:44.915
useful for complicated tasks.

185
00:06:44.915 --> 00:06:49.620
For instance, I do
some vision stuff,

186
00:06:49.620 --> 00:06:51.420
some computer vision stuff,

187
00:06:51.420 --> 00:06:54.080
and that stuff I always
use a Raspberry PI for,

188
00:06:54.080 --> 00:06:55.640
or something with
an operating system

189
00:06:55.640 --> 00:06:56.870
because I don't want to do

190
00:06:56.870 --> 00:06:58.010
the vision from scratch and write

191
00:06:58.010 --> 00:06:59.870
vision algorithms in C directly.

192
00:06:59.870 --> 00:07:02.930
I would rather use the libraries

193
00:07:02.930 --> 00:07:04.370
that are built into
the operating system,

194
00:07:04.370 --> 00:07:09.510
the OpenCv libraries or
something like that. Thank you.