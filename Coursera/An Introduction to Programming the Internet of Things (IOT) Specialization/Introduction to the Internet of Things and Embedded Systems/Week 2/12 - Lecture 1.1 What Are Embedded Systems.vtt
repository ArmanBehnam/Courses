WEBVTT

1
00:00:00.000 --> 00:00:10.132
[MUSIC]

2
00:00:10.132 --> 00:00:11.504
So in this lecture we'll talk
about embedded systems and

3
00:00:11.504 --> 00:00:12.400
how they are related to IoT devices.

4
00:00:12.400 --> 00:00:16.630
There's a lot of overlap.

5
00:00:16.630 --> 00:00:21.110
Embedded systems, the term,
usually refers a lot to,

6
00:00:21.110 --> 00:00:24.930
not just how the device is used, but
also how it's implemented, how it's built,

7
00:00:24.930 --> 00:00:27.350
so there is a lot of overlap
between the two terms.

8
00:00:27.350 --> 00:00:30.300
And IoT devices are typically
embedded systems also, so

9
00:00:30.300 --> 00:00:34.295
we'll just define that and give you
an idea Idea of what embedded systems are.

10
00:00:34.295 --> 00:00:38.995
It's good to know the term embedded system
because it is still commonly used, and

11
00:00:38.995 --> 00:00:41.595
what we are building
are typically embedded systems.

12
00:00:41.595 --> 00:00:43.565
We will talk about building
later on in the class.

13
00:00:43.565 --> 00:00:45.289
They are actually usually
embedded systems.

14
00:00:47.110 --> 00:00:48.380
So what are embedded systems?

15
00:00:48.380 --> 00:00:53.490
Embedded systems are computer based
systems that don't look like computers.

16
00:00:53.490 --> 00:00:55.370
That's my simple definition.

17
00:00:55.370 --> 00:00:59.145
The complexity of a computer
is hidden from the user.

18
00:00:59.145 --> 00:01:04.080
So if you have a computer,
desktop laptop something like that.

19
00:01:04.080 --> 00:01:05.070
If you've ever used it,

20
00:01:05.070 --> 00:01:09.630
which I know you have, there
are complexities to using a computer.

21
00:01:09.630 --> 00:01:11.810
So say you want to install
some new software.

22
00:01:11.810 --> 00:01:12.640
Right?

23
00:01:12.640 --> 00:01:13.570
You install software.

24
00:01:13.570 --> 00:01:14.870
Sometimes it's easy.

25
00:01:14.870 --> 00:01:18.060
But sometimes there's a conflict,
like for instance video games.

26
00:01:18.060 --> 00:01:21.920
I used to play video games on computers,
now I use only game machines, but

27
00:01:21.920 --> 00:01:23.890
say I play a video game on a computer.

28
00:01:23.890 --> 00:01:27.000
I put the video game in there and
install it, and

29
00:01:27.000 --> 00:01:28.620
it has some conflict with the video card.

30
00:01:28.620 --> 00:01:31.750
I need a new video card, right,
to play this new video game.

31
00:01:31.750 --> 00:01:33.420
So, then I need to get new drivers for

32
00:01:33.420 --> 00:01:37.170
my video card, so
there's this whole interaction.

33
00:01:37.170 --> 00:01:39.340
The functions are not separated.

34
00:01:39.340 --> 00:01:41.700
This is different than an IOT device.

35
00:01:41.700 --> 00:01:45.190
An IOT device basically has one function.

36
00:01:45.190 --> 00:01:46.920
We talked about this last module, right.

37
00:01:46.920 --> 00:01:49.070
It has one function it's trying to do,
like the car.

38
00:01:49.070 --> 00:01:50.640
It does the car things, right.

39
00:01:50.640 --> 00:01:52.630
A camera does camera things, but

40
00:01:52.630 --> 00:01:56.840
a general purpose computer It can do a lot
of things, and so there can be conflicts.

41
00:01:56.840 --> 00:01:59.140
If I install software
to play a video game,

42
00:01:59.140 --> 00:02:02.190
that might interfere with
the software to do something else.

43
00:02:02.190 --> 00:02:04.660
So these relationships add to complexity.

44
00:02:05.910 --> 00:02:10.819
So it makes it harder to use a standard
computer than to use, say an IOT device.

45
00:02:11.890 --> 00:02:13.850
Now an embedded system, and

46
00:02:13.850 --> 00:02:17.380
IOT devices are generally embedded,
they hide the complexity from the user.

47
00:02:17.380 --> 00:02:20.710
So the picture we've got here this is
like some kind of a scale let's say,

48
00:02:20.710 --> 00:02:22.810
and say it's an IOT scale,

49
00:02:22.810 --> 00:02:27.110
so the user doesn't have to see
the complexity of what's going on inside.

50
00:02:27.110 --> 00:02:31.060
The user just knows how to use it,
so it has a very simple interface.

51
00:02:31.060 --> 00:02:34.020
And this is where the term
embedded comes from.

52
00:02:34.020 --> 00:02:36.300
The complexity is embedded
inside the device,

53
00:02:36.300 --> 00:02:38.640
the user doesn't have to
deal with the complexity.

54
00:02:38.640 --> 00:02:42.240
So that's what an embedded system is,
how the term came about.

55
00:02:42.240 --> 00:02:45.780
Now these embedded systems are much
more common in desktops and laptops

56
00:02:45.780 --> 00:02:50.450
because there is computational ability
built into a lot of different devices.

57
00:02:50.450 --> 00:02:54.700
Now one thing to notice about embedded
systems isn't necessarily different.

58
00:02:54.700 --> 00:02:57.780
Not necessarily, but
can be different than IOT devices.

59
00:02:57.780 --> 00:03:00.500
IOT devices are almost always
connected to the internet,

60
00:03:00.500 --> 00:03:02.930
thus the term Internet of Things.

61
00:03:02.930 --> 00:03:04.850
Embedded systems may or may not be.

62
00:03:04.850 --> 00:03:08.040
Embedded systems may have
computational complexity in there, but

63
00:03:08.040 --> 00:03:09.830
no network connection at all.

64
00:03:09.830 --> 00:03:12.150
And so there are a lot of uses for
devices like that.

65
00:03:12.150 --> 00:03:16.370
Things are moving from embedded to IOT
because because of the trends we talked

66
00:03:16.370 --> 00:03:20.470
about in the last module, the fact that
internet connectivity is so ubiquitous and

67
00:03:20.470 --> 00:03:22.220
it's pretty cheap to obtain.

68
00:03:22.220 --> 00:03:25.010
So a lot of these devices that
used to be just embedded,

69
00:03:25.010 --> 00:03:27.720
are now becoming networked and
so you'd call them IOT.

70
00:03:29.290 --> 00:03:30.430
So what are embedded systems?

71
00:03:30.430 --> 00:03:34.270
They're basically
everything that interacts,

72
00:03:34.270 --> 00:03:36.850
all the internet of things
devices that we've talked about.

73
00:03:36.850 --> 00:03:39.910
But plus or minus the internet part.

74
00:03:39.910 --> 00:03:44.150
So take a digital camera,
that's what we have here.

75
00:03:44.150 --> 00:03:49.030
Digital camera, a basic digital
camera might not be networked, right?

76
00:03:49.030 --> 00:03:53.276
It might just be an embedded system
where you click, press a button,

77
00:03:53.276 --> 00:03:54.580
you take a picture.

78
00:03:54.580 --> 00:03:57.940
And the picture is stored locally, but it
might not be immediately networked, right?

79
00:03:57.940 --> 00:04:01.200
So that would, you would call that
type of thing an embedded system.

80
00:04:01.200 --> 00:04:03.330
Because the complexity is
embedded within the device.

81
00:04:03.330 --> 00:04:07.385
So, a camera, an old camera, you know?

82
00:04:07.385 --> 00:04:09.280
A mechanical camera,
has the same interface.

83
00:04:09.280 --> 00:04:10.910
You press a button,
it takes a picture, right?

84
00:04:10.910 --> 00:04:14.480
New digital camera, same interface,
press a button, takes a picture,

85
00:04:14.480 --> 00:04:17.590
but there's a lot more complexity
to what's going on inside.

86
00:04:17.590 --> 00:04:19.200
So, that's the term embedded, right?

87
00:04:19.200 --> 00:04:21.730
The complexity is embedded
inside the device, and

88
00:04:21.730 --> 00:04:23.890
the user doesn't have to see it.

89
00:04:23.890 --> 00:04:27.530
The user can benefit from the complexity,
but using a very simple interface.

90
00:04:30.140 --> 00:04:34.970
Now sometimes embedded systems don't
interact directly with the user, but

91
00:04:34.970 --> 00:04:37.640
they interact with the user
through another device.

92
00:04:37.640 --> 00:04:38.940
So what do I mean by this?

93
00:04:38.940 --> 00:04:42.470
Let's take this, take this memory,
this thumb drive right.

94
00:04:42.470 --> 00:04:46.400
Now a thumb drive, you've seen this
type of thumb drive, it stores data.

95
00:04:46.400 --> 00:04:49.400
This type of thing does not interact
directly with the user, right.

96
00:04:49.400 --> 00:04:53.400
A human doesn't have, doesn't connect this
up to their body or something, right, yet.

97
00:04:53.400 --> 00:04:55.510
Right now they connect it to their
computer or something like that or

98
00:04:55.510 --> 00:04:57.120
their phone or whatever it is.

99
00:04:57.120 --> 00:04:58.730
And then they interact with it,

100
00:04:58.730 --> 00:05:01.710
they can access the files on
it through another device.

101
00:05:01.710 --> 00:05:04.100
So you would also call
this an embedded system,

102
00:05:04.100 --> 00:05:06.360
even though it's not directly
interacting with the human.

103
00:05:08.150 --> 00:05:10.008
And you see this in other
devices like a car.

104
00:05:10.008 --> 00:05:12.890
The anti-lock braking system inside a car.

105
00:05:12.890 --> 00:05:15.870
That's interacting with a human but
not directly, right?

106
00:05:15.870 --> 00:05:19.300
The human presses the brake pedal, and the
brake pedal talks to the anti-lock braking

107
00:05:19.300 --> 00:05:24.450
system, so the human interacts with the
car, and the car talks to it's sub-system.

108
00:05:24.450 --> 00:05:26.460
One big property of embedded systems and

109
00:05:26.460 --> 00:05:31.150
a difference in embedded system design
is that efficiency is really important.

110
00:05:31.150 --> 00:05:32.580
So what that generally means is,

111
00:05:32.580 --> 00:05:37.250
that It's not enough to get
the design to work, to do its task.

112
00:05:37.250 --> 00:05:41.610
It has to do its task in an elegant,
let's say an elegant way, okay?

113
00:05:41.610 --> 00:05:45.240
Either it has to do it fast, or
it has to do it with low power, or

114
00:05:45.240 --> 00:05:47.810
it has to do it at low price, right?

115
00:05:47.810 --> 00:05:49.740
So it's not enough just to get it to work.

116
00:05:49.740 --> 00:05:53.900
And this is actually a big difference
between embedded system design and, say,

117
00:05:53.900 --> 00:05:55.230
traditional software design.

118
00:05:55.230 --> 00:05:57.530
So So, I teach programming too.

119
00:05:57.530 --> 00:06:01.420
When we teach programming, generally, we
just teach how you get something to work.

120
00:06:01.420 --> 00:06:04.680
Here, your goal is to get this code
to do what it's supposed to do.

121
00:06:04.680 --> 00:06:08.240
Whatever I wanna do, sort this list of
items, or something like that, all right?

122
00:06:08.240 --> 00:06:11.680
But, I'm not usually saying in that class,
it has to sort this list of items, and

123
00:06:11.680 --> 00:06:14.340
it has to use the minimum
amount of memory possible.

124
00:06:14.340 --> 00:06:18.210
I'm not saying it has to sort these items,
and it has to do it within one second.

125
00:06:18.210 --> 00:06:19.990
Right?
I don't put these constraints on it.

126
00:06:19.990 --> 00:06:21.690
I just say get it to work.

127
00:06:21.690 --> 00:06:25.510
But with embedded system design,
you care a lot about the efficiency.

128
00:06:25.510 --> 00:06:26.500
You can't just get it to work.

129
00:06:26.500 --> 00:06:28.500
It's got to do it in an efficient manner.

130
00:06:28.500 --> 00:06:34.850
So what that means, is that, so that
the reason for these constraints is that,

131
00:06:34.850 --> 00:06:39.200
you know, most of these devices
are used in cost critical markets.

132
00:06:39.200 --> 00:06:40.760
Or in life critical, right?

133
00:06:40.760 --> 00:06:44.720
So if it's using medical or military,
people's lives depend on these devices.

134
00:06:44.720 --> 00:06:47.570
And if using cost-critical device
that compute consumer electronics,

135
00:06:47.570 --> 00:06:49.180
the cost is important.

136
00:06:49.180 --> 00:06:53.280
But, either way there's some
constraints that are important to you.

137
00:06:53.280 --> 00:06:54.510
Besides just getting the thing to work,

138
00:06:54.510 --> 00:06:56.820
it's gotta work within
a tight set of constraints.

139
00:06:56.820 --> 00:07:01.410
So, for instance,
say it's a consumer device like a phone.

140
00:07:01.410 --> 00:07:03.740
So manufacturing costs, and design costs,

141
00:07:03.740 --> 00:07:06.350
and time-to-market,
those things are primary.

142
00:07:06.350 --> 00:07:08.510
Because you want it to be cheap, right?

143
00:07:08.510 --> 00:07:11.390
You want to make money off the device,
so the cost has to be low.

144
00:07:11.390 --> 00:07:13.850
Also, time-to-market,
because you have competitors.

145
00:07:13.850 --> 00:07:16.660
And this competitor's coming out with
a new phone on this date, so you have to

146
00:07:16.660 --> 00:07:20.190
come out on the same date with a phone
that's better than them, let's say.

147
00:07:20.190 --> 00:07:21.120
So those things are primary.

148
00:07:22.140 --> 00:07:23.990
But on the other hand,
if you're, this is the military.

149
00:07:23.990 --> 00:07:27.590
This is going into a tank or weapon
system, and people's lives depend on it,

150
00:07:27.590 --> 00:07:29.760
and it's life-critical.

151
00:07:29.760 --> 00:07:32.260
Then, you care about performance and
power more.

152
00:07:32.260 --> 00:07:35.172
So if you're in the military, you might
say, look, we'll pay millions of dollars

153
00:07:35.172 --> 00:07:40.060
for this device as long as it works and it
can effectively do what we need it to do.

154
00:07:40.060 --> 00:07:42.130
So cost becomes less important.

155
00:07:42.130 --> 00:07:44.610
But power and performance really matter.

156
00:07:44.610 --> 00:07:46.180
And same thing with medical, right?

157
00:07:46.180 --> 00:07:49.780
You might be a lot more willing to
pay a lot of money for a device.

158
00:07:49.780 --> 00:07:51.830
But it better work and
it better, you know,

159
00:07:51.830 --> 00:07:53.300
maintain your heart the way
that it's supposed to.

160
00:07:53.300 --> 00:07:54.170
Like a pace maker.

161
00:07:54.170 --> 00:07:58.540
That thing better be, have high
reliability and it better, you know,

162
00:07:58.540 --> 00:08:01.090
rate your,
control the pace of your heart properly.

163
00:08:01.090 --> 00:08:04.230
So if that means costing
more money then so be it.

164
00:08:04.230 --> 00:08:07.330
So in these imbedded devices,

165
00:08:07.330 --> 00:08:10.270
there's always this tight set of
constraints that you're working under.

166
00:08:10.270 --> 00:08:11.520
So it's not enough to get it to work,

167
00:08:11.520 --> 00:08:14.210
you gotta get it to work within the set
of constraints that you're given.

168
00:08:16.560 --> 00:08:19.040
So this is very different than
traditional software engineering,

169
00:08:19.040 --> 00:08:22.520
where you just wanna get it to work and
get it to work some how.

170
00:08:22.520 --> 00:08:25.440
And the assumption there is that
Moore's Law will save you eventually so

171
00:08:25.440 --> 00:08:29.550
by Moore's Law, you may have heard of this
before but Moore's law just says let's

172
00:08:29.550 --> 00:08:32.270
say that approximately says
that machines get faster and

173
00:08:32.270 --> 00:08:34.830
more computationally efficient every year,
right?

174
00:08:34.830 --> 00:08:37.100
They get more dense and faster.

175
00:08:37.100 --> 00:08:40.400
Which by the way, Moore's law is
slowing down but still, this happens.

176
00:08:40.400 --> 00:08:41.520
Machines improve.

177
00:08:41.520 --> 00:08:46.090
So, software engineering often you'll just
either say, look, just get it to work and

178
00:08:46.090 --> 00:08:50.580
if it's slow it's okay, because process or
performance is improving every year.

179
00:08:50.580 --> 00:08:52.540
And so in the future it won't matter.

180
00:08:52.540 --> 00:08:53.050
Right.

181
00:08:53.050 --> 00:08:57.040
So that was the background assumption
to a lot of software engineering.

182
00:08:57.040 --> 00:08:59.330
But a better systems,
you can't think like that.

183
00:08:59.330 --> 00:09:01.140
You have to think loo,k
not only does it work.

184
00:09:01.140 --> 00:09:02.500
It's gotta be working fast.

185
00:09:02.500 --> 00:09:04.317
It's gotta be working low power and
all this.

186
00:09:06.594 --> 00:09:07.250
Thank you.

187
00:09:07.250 --> 00:09:15.819
[MUSIC]