WEBVTT

1
00:00:00.020 --> 00:00:02.100
So, we're going to talk about

2
00:00:02.100 --> 00:00:04.380
microcontroller
characteristics right now.

3
00:00:04.380 --> 00:00:07.005
The different characteristics
of microcontrollers.

4
00:00:07.005 --> 00:00:09.090
Now, the reason why
this is important

5
00:00:09.090 --> 00:00:11.070
for making IoT systems
is because when you

6
00:00:11.070 --> 00:00:13.620
make it an IoT systems probably

7
00:00:13.620 --> 00:00:15.720
one of the early
decisions about how to

8
00:00:15.720 --> 00:00:17.835
implement the system
is going to be,

9
00:00:17.835 --> 00:00:20.775
which microcontroller
should you use, right?

10
00:00:20.775 --> 00:00:22.860
Now, there are a wide range

11
00:00:22.860 --> 00:00:24.960
of choices with microcontrollers,

12
00:00:24.960 --> 00:00:26.970
and you're going to have
to find one to use.

13
00:00:26.970 --> 00:00:29.810
Now, a lot of these decisions
are pre-done for you, like,

14
00:00:29.810 --> 00:00:31.005
if you work in a company,

15
00:00:31.005 --> 00:00:32.160
they use a particular brand,

16
00:00:32.160 --> 00:00:33.345
we use Freescale, whatever,

17
00:00:33.345 --> 00:00:35.130
that's what you use, right?

18
00:00:35.130 --> 00:00:37.600
Even within those
constraints, you get,

19
00:00:37.600 --> 00:00:38.895
even be stuck with, say,

20
00:00:38.895 --> 00:00:40.230
you're only using Freescale.

21
00:00:40.230 --> 00:00:42.260
It's a ton of
microcontrollers you can use,

22
00:00:42.260 --> 00:00:42.770
all with set of

23
00:00:42.770 --> 00:00:44.915
different properties
and things like this.

24
00:00:44.915 --> 00:00:46.310
You got to pick the one
that's right for

25
00:00:46.310 --> 00:00:48.800
your project because
another feature of

26
00:00:48.800 --> 00:00:50.495
IoT systems is that they are

27
00:00:50.495 --> 00:00:53.300
generally constrained,
tightly constrained.

28
00:00:53.300 --> 00:00:56.010
So, it's not like
a desktop laptop.

29
00:00:56.010 --> 00:00:58.080
Right. If you look
at a desktop laptop,

30
00:00:58.080 --> 00:01:00.885
those things are over engineered,

31
00:01:00.885 --> 00:01:02.840
in the sense that you get

32
00:01:02.840 --> 00:01:05.780
some quad core processors
run in it and I don't know,

33
00:01:05.780 --> 00:01:07.685
three gigahertz
something like this.

34
00:01:07.685 --> 00:01:11.090
Regular user doesn't use that.

35
00:01:11.090 --> 00:01:12.500
In fact, it's running,

36
00:01:12.500 --> 00:01:15.830
it's sort of two percent
capacity 99 percent of the time.

37
00:01:15.830 --> 00:01:17.045
So, you start playing a game.

38
00:01:17.045 --> 00:01:19.595
Certain games, they will
suck up that power,

39
00:01:19.595 --> 00:01:21.770
they will use what
the computer has,

40
00:01:21.770 --> 00:01:23.030
but vast majority of

41
00:01:23.030 --> 00:01:24.800
the time that processor
is sitting there at

42
00:01:24.800 --> 00:01:27.135
two percent basically idling

43
00:01:27.135 --> 00:01:28.740
because you don't
need four cores,

44
00:01:28.740 --> 00:01:30.750
you don't need that clock rate,

45
00:01:30.750 --> 00:01:32.745
you don't need
everything that it has.

46
00:01:32.745 --> 00:01:35.955
IoT based systems,
those things are cheap,

47
00:01:35.955 --> 00:01:37.250
you want to be cheap.

48
00:01:37.250 --> 00:01:39.260
You do not want to buy some big

49
00:01:39.260 --> 00:01:42.110
powerful microcontroller
that you don't need.

50
00:01:42.110 --> 00:01:44.520
You're always saving money
trying to say, "Look,

51
00:01:44.520 --> 00:01:45.750
what is the cheapest
thing that just

52
00:01:45.750 --> 00:01:47.325
barely does what I need to do?"

53
00:01:47.325 --> 00:01:49.250
So, what you need is,

54
00:01:49.250 --> 00:01:50.840
you need to have in mind a set of

55
00:01:50.840 --> 00:01:52.805
characteristics that your
microcontroller needs,

56
00:01:52.805 --> 00:01:54.560
so the bare minimum
for your system.

57
00:01:54.560 --> 00:01:56.660
Then, you look through
the data sheets for

58
00:01:56.660 --> 00:01:59.930
the microcontrollers to figure
out which one has that,

59
00:01:59.930 --> 00:02:02.125
just barely, which is the
cheapest one that has that.

60
00:02:02.125 --> 00:02:03.525
Now, a data sheet,

61
00:02:03.525 --> 00:02:04.850
we're not going to look
at a data sheet because

62
00:02:04.850 --> 00:02:06.130
those are painful look at.

63
00:02:06.130 --> 00:02:07.580
A data sheet is basically

64
00:02:07.580 --> 00:02:08.870
the sheet that has

65
00:02:08.870 --> 00:02:10.880
all the information about
the particular microcontroller.

66
00:02:10.880 --> 00:02:13.760
So, if you ever want to
look up a micro control,

67
00:02:13.760 --> 00:02:15.965
you can look on
the top of the chip.

68
00:02:15.965 --> 00:02:17.659
You can see the name of
the microcontroller,

69
00:02:17.659 --> 00:02:19.610
its part number and
everything, you type that in,

70
00:02:19.610 --> 00:02:22.010
into Google, and you say "data

71
00:02:22.010 --> 00:02:23.360
sheet," and you will

72
00:02:23.360 --> 00:02:25.310
come up with a data
sheet, most likely.

73
00:02:25.310 --> 00:02:27.095
As data sheet, you
might look at one,

74
00:02:27.095 --> 00:02:29.860
they are definitely
complicated to read.

75
00:02:29.860 --> 00:02:32.270
They have lots of
different details

76
00:02:32.270 --> 00:02:34.320
about the microcontroller.

77
00:02:34.520 --> 00:02:36.960
There are certain
information in these,

78
00:02:36.960 --> 00:02:38.390
certain things in these
we really need to

79
00:02:38.390 --> 00:02:41.510
understand in order to
make reasonable decisions.

80
00:02:41.510 --> 00:02:42.800
So, we don't have to
understand everything

81
00:02:42.800 --> 00:02:44.015
in there, we will not.

82
00:02:44.015 --> 00:02:46.880
Certain high level characteristics
of a microcontroller,

83
00:02:46.880 --> 00:02:49.070
you should know what they mean,

84
00:02:49.070 --> 00:02:50.930
and so when you look
at a data sheet,

85
00:02:50.930 --> 00:02:52.280
say the front page
of the data sheet,

86
00:02:52.280 --> 00:02:53.870
you can at least tell
superficially, "Yeah,

87
00:02:53.870 --> 00:02:55.565
it has this, it has
that, has that.

88
00:02:55.565 --> 00:02:58.055
That's what I need or I
don't need that." So on.

89
00:02:58.055 --> 00:03:00.290
So, let's talk about
the basic characteristics

90
00:03:00.290 --> 00:03:02.075
of microcontrollers that
you might look into.

91
00:03:02.075 --> 00:03:03.590
Again, also another thing,

92
00:03:03.590 --> 00:03:05.665
let me mention is
that, in this class,

93
00:03:05.665 --> 00:03:07.250
you won't be making
this decision.

94
00:03:07.250 --> 00:03:08.330
You're not going to
be deciding which

95
00:03:08.330 --> 00:03:09.740
microcontroller
you're going to use.

96
00:03:09.740 --> 00:03:11.945
In this course, we use
an Arduino, right?

97
00:03:11.945 --> 00:03:13.040
Then, next set of course,

98
00:03:13.040 --> 00:03:15.230
we can use Raspberry Pi,
we're set with that.

99
00:03:15.230 --> 00:03:16.840
But I'm saying outside
of the course,

100
00:03:16.840 --> 00:03:19.060
when you and design
your own IoT system,

101
00:03:19.060 --> 00:03:21.695
you will need to pick
a microcontroller.

102
00:03:21.695 --> 00:03:25.785
Okay. Datapath bitwidth.

103
00:03:25.785 --> 00:03:27.630
Bitwidth, what that means is,

104
00:03:27.630 --> 00:03:30.945
it's a number of bits
in each register.

105
00:03:30.945 --> 00:03:33.275
A register storage element
to store as a number.

106
00:03:33.275 --> 00:03:35.165
So, the bitwidth
basically tells you

107
00:03:35.165 --> 00:03:38.135
the size of most
numbers in your system.

108
00:03:38.135 --> 00:03:39.380
How many bits?

109
00:03:39.380 --> 00:03:42.080
So, every number is
represented in binary as

110
00:03:42.080 --> 00:03:43.280
a series of bits which are

111
00:03:43.280 --> 00:03:45.635
binary digits,
either zero or one.

112
00:03:45.635 --> 00:03:47.840
The more bits, the better, okay?

113
00:03:47.840 --> 00:03:49.745
So, what do I mean by that?

114
00:03:49.745 --> 00:03:53.450
If you have more bits,
64 bits let's say,

115
00:03:53.450 --> 00:03:55.310
that means you can get more
accuracy than you could

116
00:03:55.310 --> 00:03:57.515
with 16 bits,
something like that.

117
00:03:57.515 --> 00:04:00.449
So, you get more accuracy,

118
00:04:00.449 --> 00:04:01.740
you get more data throughput.

119
00:04:01.740 --> 00:04:04.720
So, basically if you're
processing on 64-bit numbers,

120
00:04:04.720 --> 00:04:07.280
there's more data
processing than you can

121
00:04:07.280 --> 00:04:10.085
do then if you processing
on 8-bit numbers.

122
00:04:10.085 --> 00:04:11.780
I know we're not going
to go into architecture,

123
00:04:11.780 --> 00:04:14.435
but roughly that's what
datapath bitwidth means.

124
00:04:14.435 --> 00:04:16.145
Now, there's a limit.

125
00:04:16.145 --> 00:04:18.470
I mean you don't need
excessive accuracy

126
00:04:18.470 --> 00:04:19.970
in your average system, right?

127
00:04:19.970 --> 00:04:22.810
So, you know an 8-bit
microcontroller, like,

128
00:04:22.810 --> 00:04:24.560
the Arduino that we're using,

129
00:04:24.560 --> 00:04:27.680
is based on an 8-bit
microcontroller. That is sufficient.

130
00:04:27.680 --> 00:04:29.660
That is minimal, but
that is sufficient

131
00:04:29.660 --> 00:04:32.010
for the task that we do
in this class, right?

132
00:04:32.010 --> 00:04:33.890
We don't need high accuracy.

133
00:04:33.890 --> 00:04:36.020
We're just doing
simple control operations.

134
00:04:36.020 --> 00:04:37.970
We don't need
accuracy and numbers.

135
00:04:37.970 --> 00:04:39.530
So, it's a bitwidth

136
00:04:39.530 --> 00:04:41.000
is something you have to
think about depending

137
00:04:41.000 --> 00:04:45.275
on the task that you're
performing. Input/output pins.

138
00:04:45.275 --> 00:04:47.150
Now, this is actually
an important thing

139
00:04:47.150 --> 00:04:48.650
because it's often a bottleneck.

140
00:04:48.650 --> 00:04:50.060
So, you got to your
microcontroller.

141
00:04:50.060 --> 00:04:52.700
The microcontroller is
the center of the system.

142
00:04:52.700 --> 00:04:53.960
It's connected to everything,

143
00:04:53.960 --> 00:04:56.090
is orchestrating
the whole system, right?

144
00:04:56.090 --> 00:04:57.530
So, the microcontroller
has to be connected to

145
00:04:57.530 --> 00:04:58.805
all the different components

146
00:04:58.805 --> 00:05:00.035
that you want to
put in your system.

147
00:05:00.035 --> 00:05:02.960
Now, maybe not all but
to a lot of them, okay?

148
00:05:02.960 --> 00:05:05.690
It requires pins to connect
it to these things.

149
00:05:05.690 --> 00:05:07.220
So, maybe you need three pins

150
00:05:07.220 --> 00:05:08.720
to connect to
one integrated circuit,

151
00:05:08.720 --> 00:05:10.145
and five pins to connect another,

152
00:05:10.145 --> 00:05:12.320
and so on depending on
what the circuit is,

153
00:05:12.320 --> 00:05:14.330
you know, how many pins
it has on its interface.

154
00:05:14.330 --> 00:05:16.520
You can easily chew
up all the pins,

155
00:05:16.520 --> 00:05:17.810
you can easily use
up all the pins on

156
00:05:17.810 --> 00:05:19.280
our microcontroller because

157
00:05:19.280 --> 00:05:20.565
there are these microcontrollers,

158
00:05:20.565 --> 00:05:22.550
generally, they don't
have too many pins.

159
00:05:22.550 --> 00:05:25.460
So, you have to be careful
about how you use the pins.

160
00:05:25.460 --> 00:05:28.550
So, that's why very early
in the design process,

161
00:05:28.550 --> 00:05:30.320
you have to just sketch
out your design,

162
00:05:30.320 --> 00:05:31.280
figure out what the different

163
00:05:31.280 --> 00:05:32.690
components are you going to use,

164
00:05:32.690 --> 00:05:34.190
and how many pins each one of

165
00:05:34.190 --> 00:05:36.005
them needs to go talk
to the microcontroller.

166
00:05:36.005 --> 00:05:37.460
So, you can get a number,

167
00:05:37.460 --> 00:05:39.245
like say, okay, I need 40 pins.

168
00:05:39.245 --> 00:05:41.030
Then you can find a data
sheet that reports it

169
00:05:41.030 --> 00:05:43.170
has at least 40 pins
and so on, right?

170
00:05:43.170 --> 00:05:45.935
So, input/output pins are
important for that reason.

171
00:05:45.935 --> 00:05:50.295
Performance, okay. So,
performance is important.

172
00:05:50.295 --> 00:05:53.250
It depends on
the application, right?

173
00:05:53.250 --> 00:05:55.455
So, sometimes it's important,
sometimes it's not.

174
00:05:55.455 --> 00:05:57.640
Now, one thing to note
with performances,

175
00:05:57.640 --> 00:05:59.780
many times when you're
making an IoT device

176
00:05:59.780 --> 00:06:02.090
it is interacting
with a human, right.

177
00:06:02.090 --> 00:06:03.830
It's a device that's dealing with

178
00:06:03.830 --> 00:06:05.540
the human and humans are slow.

179
00:06:05.540 --> 00:06:08.720
So, humans, they don't need
you to respond too quickly.

180
00:06:08.720 --> 00:06:10.235
Now, when I say not too quickly,

181
00:06:10.235 --> 00:06:13.610
let's say you're putting
images on a screen.

182
00:06:13.610 --> 00:06:15.090
These images on a screen,

183
00:06:15.090 --> 00:06:17.340
if you put 30 a
second on a screen,

184
00:06:17.340 --> 00:06:19.055
a human will be very
happy with that.

185
00:06:19.055 --> 00:06:21.170
Human will see it, say mode,

186
00:06:21.170 --> 00:06:22.670
and everything will
be smooth, right?

187
00:06:22.670 --> 00:06:25.570
Now, 30 frames a second,
30 things a second,

188
00:06:25.570 --> 00:06:27.770
operations second is very

189
00:06:27.770 --> 00:06:29.630
little for many processes

190
00:06:29.630 --> 00:06:31.055
and that depends
on the processor.

191
00:06:31.055 --> 00:06:33.560
Maybe a processor could
do a lot more than that,

192
00:06:33.560 --> 00:06:36.155
but it's not necessary
because the human is slow.

193
00:06:36.155 --> 00:06:39.070
So, you're supposed to get
with this with sound, right?

194
00:06:39.070 --> 00:06:44.670
With audio, a human can only
hear what 22 kilohertz,

195
00:06:44.670 --> 00:06:46.205
I think, is a maximum0 frequency.

196
00:06:46.205 --> 00:06:47.990
That is not very fast,

197
00:06:47.990 --> 00:06:50.765
okay, 22,000 operations a second.

198
00:06:50.765 --> 00:06:56.340
That's not a high rate of
processor speed, right?

199
00:06:56.340 --> 00:06:59.780
So, a processor can
process audio data much

200
00:06:59.780 --> 00:07:03.365
faster than a human can
hear the data, right?

201
00:07:03.365 --> 00:07:05.570
So, you can use
a pretty slow processor and

202
00:07:05.570 --> 00:07:08.065
still produce
a satisfactory audio.

203
00:07:08.065 --> 00:07:09.410
So, performance is important.

204
00:07:09.410 --> 00:07:11.420
You have to consider that
depends on your application.

205
00:07:11.420 --> 00:07:12.890
Video though, video requires

206
00:07:12.890 --> 00:07:14.749
a lot more even those
30 frames a second,

207
00:07:14.749 --> 00:07:16.550
each frame might have
many millions of

208
00:07:16.550 --> 00:07:17.570
pixels and you might have to do

209
00:07:17.570 --> 00:07:18.710
lots of processing on that.

210
00:07:18.710 --> 00:07:21.710
So, video generally
requires a higher rate,

211
00:07:21.710 --> 00:07:23.330
but audio you know,

212
00:07:23.330 --> 00:07:25.610
if you're just an
audio or tactile,

213
00:07:25.610 --> 00:07:26.840
maybe if somebody's
pressing a button,

214
00:07:26.840 --> 00:07:30.630
something like that, very slow
clock rate is sufficient.

215
00:07:31.420 --> 00:07:35.210
There we go, okay. So, some
other features, timers.

216
00:07:35.210 --> 00:07:36.770
There are other components inside

217
00:07:36.770 --> 00:07:38.420
your microcontroller that are

218
00:07:38.420 --> 00:07:42.020
commonly useful to an IoT
system like a timer.

219
00:07:42.020 --> 00:07:45.050
Now, you need a timer
for any type of

220
00:07:45.050 --> 00:07:47.060
real-time application
and a lot of

221
00:07:47.060 --> 00:07:50.060
IoT systems have
real time functionality in them.

222
00:07:50.060 --> 00:07:51.350
So, say you want

223
00:07:51.350 --> 00:07:52.835
something to happen at
a certain deadline.

224
00:07:52.835 --> 00:07:55.040
I want to sample this sound

225
00:07:55.040 --> 00:07:56.660
every one thousandth of

226
00:07:56.660 --> 00:07:58.025
a second I want to
sample the sound.

227
00:07:58.025 --> 00:07:59.660
Then you need a timer to trigger

228
00:07:59.660 --> 00:08:01.790
that event to happen
at that rate, right?

229
00:08:01.790 --> 00:08:05.270
So, or I want to
sample a monitor,

230
00:08:05.270 --> 00:08:07.235
I want to sample
some temperature monitor

231
00:08:07.235 --> 00:08:08.900
at some regular period, right?

232
00:08:08.900 --> 00:08:10.310
You need a timer to set that,

233
00:08:10.310 --> 00:08:11.815
to force it to
happen at that rate.

234
00:08:11.815 --> 00:08:14.750
So, timer is a really
important in microcontrollers.

235
00:08:14.750 --> 00:08:16.250
So, you need a few timers.

236
00:08:16.250 --> 00:08:18.200
When you considering the timers,

237
00:08:18.200 --> 00:08:20.300
there's an accuracy, a
timer accuracy issue.

238
00:08:20.300 --> 00:08:22.370
You got to think
how much accuracy do you need in

239
00:08:22.370 --> 00:08:23.630
the timing and then
that determines

240
00:08:23.630 --> 00:08:25.250
the bitwidth at
the timer, right?.

241
00:08:25.250 --> 00:08:26.930
So, an 8-bit timer is less

242
00:08:26.930 --> 00:08:29.065
accurate than the 16-bit timer.

243
00:08:29.065 --> 00:08:31.580
We'll get to that later
when we deal with timers.

244
00:08:31.580 --> 00:08:34.340
Anyway timers are components
that you look for,

245
00:08:34.340 --> 00:08:36.725
you always want a few of
them in a microcontroller.

246
00:08:36.725 --> 00:08:39.035
Analog to digital converters.

247
00:08:39.035 --> 00:08:42.795
So, what this is for is
to read analog signals.

248
00:08:42.795 --> 00:08:45.890
Now, the issue here is

249
00:08:45.890 --> 00:08:47.780
that microcontrollers are

250
00:08:47.780 --> 00:08:49.835
generally digital devices, okay.

251
00:08:49.835 --> 00:08:51.740
When I say digital,
all the numbers

252
00:08:51.740 --> 00:08:53.480
are zeros and one, off or on,

253
00:08:53.480 --> 00:08:57.695
they're discrete values, zero
or one, nothing in between.

254
00:08:57.695 --> 00:09:01.700
Now, analogue is
a continuous set of values.

255
00:09:01.700 --> 00:09:02.450
So, the difference between

256
00:09:02.450 --> 00:09:03.620
analog and digital is the same as

257
00:09:03.620 --> 00:09:05.810
the difference between
real numbers and integers,

258
00:09:05.810 --> 00:09:07.220
right? They're discrete integers.

259
00:09:07.220 --> 00:09:10.075
You can have zero,one, two
but you can't have 1.5.

260
00:09:10.075 --> 00:09:11.670
While analog is continuous,

261
00:09:11.670 --> 00:09:13.495
you can have any number anywhere.

262
00:09:13.495 --> 00:09:15.980
Now, controllers
microcontrollers in

263
00:09:15.980 --> 00:09:17.180
integrated circuits
in general they

264
00:09:17.180 --> 00:09:18.920
are almost always digital,

265
00:09:18.920 --> 00:09:21.410
completely digital
because it's much

266
00:09:21.410 --> 00:09:22.880
easier to design
a digital circuit

267
00:09:22.880 --> 00:09:24.275
than it is to design
an analog circuit.

268
00:09:24.275 --> 00:09:25.475
But they are digital,

269
00:09:25.475 --> 00:09:27.330
but the world is analog.

270
00:09:27.330 --> 00:09:28.510
So, what I mean by that?

271
00:09:28.510 --> 00:09:31.370
Save this light that is in
my face while we're recording.

272
00:09:31.370 --> 00:09:33.245
This light can be
a little brighter,

273
00:09:33.245 --> 00:09:34.355
I hope is not a little brighter,

274
00:09:34.355 --> 00:09:35.515
little brighter, a little dimmer.

275
00:09:35.515 --> 00:09:37.650
Okay. It's not just off or on.

276
00:09:37.650 --> 00:09:39.370
They can increase the brightness,

277
00:09:39.370 --> 00:09:41.745
decrease it in an analog way.

278
00:09:41.745 --> 00:09:46.280
So, phenomena that humans
interact with, sound, right.

279
00:09:46.280 --> 00:09:47.540
I can talk a little louder.

280
00:09:47.540 --> 00:09:49.220
I can talk a little
softer and so on.

281
00:09:49.220 --> 00:09:51.290
So, that's an analog phenomenon.

282
00:09:51.290 --> 00:09:52.340
So, the world is generally

283
00:09:52.340 --> 00:09:54.325
analog to the
perceptions of a human.

284
00:09:54.325 --> 00:09:56.160
These computers are digital.

285
00:09:56.160 --> 00:09:59.390
So, if you want a an IoT device

286
00:09:59.390 --> 00:10:01.310
to process these
analog phenomenon,

287
00:10:01.310 --> 00:10:03.305
it has to convert it
into a digital number.

288
00:10:03.305 --> 00:10:05.210
So, the brightness
of this light, say,

289
00:10:05.210 --> 00:10:07.520
I want my IoT system to do

290
00:10:07.520 --> 00:10:09.110
something when the brightness

291
00:10:09.110 --> 00:10:10.475
reaches a certain threshold,

292
00:10:10.475 --> 00:10:12.185
it's going to hesitate.

293
00:10:12.185 --> 00:10:13.430
it needs to be able to take that

294
00:10:13.430 --> 00:10:15.080
analog value of
that light brightness,

295
00:10:15.080 --> 00:10:18.380
convert it to a digital number
that I can use in my code.

296
00:10:18.380 --> 00:10:20.055
I can say if brightness
is greater than

297
00:10:20.055 --> 00:10:22.670
1,000 or some digital
number, right?

298
00:10:22.670 --> 00:10:25.010
So, analog to digital
converters are important

299
00:10:25.010 --> 00:10:27.395
in an IoT devices
because you want it

300
00:10:27.395 --> 00:10:30.395
generally is very common
to take analog phenomenon

301
00:10:30.395 --> 00:10:32.090
and convert it to digital values

302
00:10:32.090 --> 00:10:33.830
that you can process
in your code.

303
00:10:33.830 --> 00:10:37.010
So, A to D converter
analog to digital,

304
00:10:37.010 --> 00:10:38.720
A to D usually

305
00:10:38.720 --> 00:10:41.290
want one or more of these
in a microcontroller.

306
00:10:41.290 --> 00:10:43.160
I'll note right now
Raspberry Pi does not

307
00:10:43.160 --> 00:10:45.380
actually have an analog
digital converter,

308
00:10:45.380 --> 00:10:46.880
so that limits it
in certain ways,

309
00:10:46.880 --> 00:10:49.039
but it is very calm
for microcontroller

310
00:10:49.039 --> 00:10:51.910
to have at least one analog
to digital converter.

311
00:10:51.910 --> 00:10:55.845
Low power modes. These
are common nowadays, too.

312
00:10:55.845 --> 00:10:57.780
When I say nowadays,
I'm an old guy,

313
00:10:57.780 --> 00:10:59.500
so I remember back
in the old days,

314
00:10:59.500 --> 00:11:01.385
when nobody cared about power,
there's plenty of power.

315
00:11:01.385 --> 00:11:03.390
That's because everything was,

316
00:11:03.390 --> 00:11:05.115
things weren't battery powered,

317
00:11:05.115 --> 00:11:06.530
everything was
plugged into a wall.

318
00:11:06.530 --> 00:11:09.620
Also microcontrollers were
just much slower then,

319
00:11:09.620 --> 00:11:11.855
so, they didn't
consume much power.

320
00:11:11.855 --> 00:11:15.199
Nowadays, things
are battery driven,

321
00:11:15.199 --> 00:11:17.930
things are fast, right?

322
00:11:17.930 --> 00:11:19.640
The clock rate is fast
and the faster it runs,

323
00:11:19.640 --> 00:11:21.020
the more power it uses.

324
00:11:21.020 --> 00:11:24.275
So, power is a very
big issue these days,

325
00:11:24.275 --> 00:11:25.670
when you're doing integrated

326
00:11:25.670 --> 00:11:27.550
circuit design and system design.

327
00:11:27.550 --> 00:11:29.930
So, in integrated circuits,

328
00:11:29.930 --> 00:11:32.750
it is very common to
have low power modes,

329
00:11:32.750 --> 00:11:33.800
in microcontrollers you can have

330
00:11:33.800 --> 00:11:34.955
different low power modes.

331
00:11:34.955 --> 00:11:36.440
So, the chip doesn't
have to be just

332
00:11:36.440 --> 00:11:38.150
completely off or completely on,

333
00:11:38.150 --> 00:11:39.770
it can have these
intermediate modes

334
00:11:39.770 --> 00:11:41.270
where certain things
are turned on,

335
00:11:41.270 --> 00:11:42.605
certain things that turned off,

336
00:11:42.605 --> 00:11:44.360
or maybe something
that's turned on,

337
00:11:44.360 --> 00:11:46.390
but it's running
at a slower rate,

338
00:11:46.390 --> 00:11:47.435
you know things like this.

339
00:11:47.435 --> 00:11:49.270
Maybe you can't use the memory,

340
00:11:49.270 --> 00:11:52.820
but it doesn't lose what
it's storing, right?

341
00:11:52.820 --> 00:11:54.535
So, it's got
this intermediate state.

342
00:11:54.535 --> 00:11:56.250
So, there in low power modes

343
00:11:56.250 --> 00:11:58.454
built into these
microcontrollers commonly,

344
00:11:58.454 --> 00:12:00.050
and we're not going to

345
00:12:00.050 --> 00:12:01.520
cover that in this class
because that's a

346
00:12:01.520 --> 00:12:02.840
little more sophisticated
than we're going

347
00:12:02.840 --> 00:12:04.910
to touch on this class,

348
00:12:04.910 --> 00:12:07.940
but more advanced IoT systems.

349
00:12:07.940 --> 00:12:09.560
Yeah, you're considering
low power modes.

350
00:12:09.560 --> 00:12:10.820
You often these things often

351
00:12:10.820 --> 00:12:11.900
run off a battery if you want

352
00:12:11.900 --> 00:12:13.070
them to run a long time and

353
00:12:13.070 --> 00:12:14.555
that's sucked down
the whole battery.

354
00:12:14.555 --> 00:12:16.370
So, that you often
want them to run

355
00:12:16.370 --> 00:12:18.910
in low power mode
when is possible.

356
00:12:18.910 --> 00:12:21.110
So, you can see this
in a data sheet.

357
00:12:21.110 --> 00:12:23.195
You can write in
the front page probably,

358
00:12:23.195 --> 00:12:26.165
you'll say that it has
certain low power modes.

359
00:12:26.165 --> 00:12:28.835
Communication protocol support.

360
00:12:28.835 --> 00:12:32.360
So, what this is and we'll
get to this more later,

361
00:12:32.360 --> 00:12:33.620
but these microcontrollers
they have

362
00:12:33.620 --> 00:12:36.005
to communicate with
other integrated circuits.

363
00:12:36.005 --> 00:12:38.570
Okay. These integrated circuits,

364
00:12:38.570 --> 00:12:40.250
the way that they communicate,

365
00:12:40.250 --> 00:12:42.845
they use some kind of
a communication protocol.

366
00:12:42.845 --> 00:12:45.300
Relatively simple
communication protocol,

367
00:12:45.300 --> 00:12:46.880
the way that they
send data to and

368
00:12:46.880 --> 00:12:48.590
from each other
over a set of pins,

369
00:12:48.590 --> 00:12:50.750
it's got to be in
a certain order with

370
00:12:50.750 --> 00:12:53.495
a certain timing and so
on. That's the protocol.

371
00:12:53.495 --> 00:12:55.610
We'll get into more detail
about these protocols later,

372
00:12:55.610 --> 00:12:57.470
but some of them are UART,

373
00:12:57.470 --> 00:13:00.380
I2C, SPI, those are some.

374
00:13:00.380 --> 00:13:02.150
We'll cover those
later in the class,

375
00:13:02.150 --> 00:13:03.785
but these are protocols

376
00:13:03.785 --> 00:13:05.360
that you can look in
the data sheet and say,

377
00:13:05.360 --> 00:13:06.650
yes it supports I2C,

378
00:13:06.650 --> 00:13:09.590
yes supports SPI, yes
supports UART, right?

379
00:13:09.590 --> 00:13:11.030
Now, this is important because

380
00:13:11.030 --> 00:13:12.290
when you're making
your bigger system,

381
00:13:12.290 --> 00:13:15.289
say you want your microcontroller

382
00:13:15.289 --> 00:13:18.005
to talk to some sram,
sram chip, right?

383
00:13:18.005 --> 00:13:21.620
This sram chip maybe it talks
I2C, but doesn't talk SPI.

384
00:13:21.620 --> 00:13:23.060
If your microcontroller doesn't

385
00:13:23.060 --> 00:13:25.710
support I2C, then
you have trouble.

386
00:13:25.710 --> 00:13:28.160
Now generally, these
microcontrollers nowadays

387
00:13:28.160 --> 00:13:30.500
they mostly support everything

388
00:13:30.500 --> 00:13:32.960
and all those I just
said and others, too.

389
00:13:32.960 --> 00:13:37.560
So generally, you have in
most basic microcontrollers,

390
00:13:37.560 --> 00:13:39.740
you have a lot of
communication protocol support,

391
00:13:39.740 --> 00:13:44.700
but you should check,
just in case. Thank you.