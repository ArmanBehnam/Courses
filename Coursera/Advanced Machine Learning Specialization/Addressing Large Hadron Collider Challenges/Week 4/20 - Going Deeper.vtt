WEBVTT

1
00:00:00.265 --> 00:00:03.505
[MUSIC]

2
00:00:03.505 --> 00:00:08.430
So, let's take a look at
more complicated example.

3
00:00:08.430 --> 00:00:13.530
So the tougher challenge comes from
the point that in SHiP settings, we will

4
00:00:15.770 --> 00:00:20.200
not have access to
origin of the shower.

5
00:00:20.200 --> 00:00:25.555
So, and here we can explore
different methods to find the shower

6
00:00:25.555 --> 00:00:30.920
in the volume of a brick,
just knowing that the shower is there.

7
00:00:30.920 --> 00:00:35.850
So one of the approaches can be
based on clustering methods.

8
00:00:35.850 --> 00:00:39.531
Some approaches can be based on
conditional random fields or

9
00:00:39.531 --> 00:00:43.440
putting in all at once,
like message passing neural networks.

10
00:00:44.580 --> 00:00:48.980
So, the solution I'm going to
describe follows this strategy.

11
00:00:50.000 --> 00:00:57.470
First, we find neighbors for
selected tracks on neighbor plates.

12
00:00:57.470 --> 00:01:01.160
Then we build chains of
5-track candidates, and

13
00:01:01.160 --> 00:01:06.590
train a classification algorithm
to deal with those 5-tracks.

14
00:01:06.590 --> 00:01:12.640
After this, we apply a cluster
showers using DB-SCAN algorithm.

15
00:01:12.640 --> 00:01:16.900
So we group those showers
together to identify

16
00:01:16.900 --> 00:01:21.410
where exactly in the volume of
a brick those showers are located.

17
00:01:22.680 --> 00:01:27.120
Let's take a look at the first stage.

18
00:01:27.120 --> 00:01:33.832
So, how do we find a neighbor for a track
that sits in the bottom left corner?

19
00:01:35.120 --> 00:01:39.348
So the grey vertical
bars represent plates, so

20
00:01:39.348 --> 00:01:43.057
there are two plates, neighbor plates.

21
00:01:43.057 --> 00:01:46.062
And on the second plate in
the middle of the picture,

22
00:01:46.062 --> 00:01:49.014
you have three different base tracks,
right?

23
00:01:49.014 --> 00:01:55.015
Imagine we prolonged the line of the left

24
00:01:55.015 --> 00:01:59.785
base track to the second plate.

25
00:01:59.785 --> 00:02:06.432
So we have to look at the combination
of features, like distances and angles,

26
00:02:06.432 --> 00:02:12.797
to find the most suitable continuation
of the original track, right?

27
00:02:12.797 --> 00:02:17.444
So, this picture shows that
we have to be careful or

28
00:02:17.444 --> 00:02:22.308
somehow find the good
combination of the distance and

29
00:02:22.308 --> 00:02:28.166
angles that can be applied,
searching for our next basetrack.

30
00:02:28.166 --> 00:02:32.601
And then we can compute
different features of

31
00:02:32.601 --> 00:02:36.925
those tracks that we have joined together.

32
00:02:36.925 --> 00:02:42.259
Like angle between directions,
impact parameters, mixed product of two

33
00:02:42.259 --> 00:02:48.285
directions, vector connecting positions
of basetracks, and some projections.

34
00:02:48.285 --> 00:02:53.371
And in this case,
we differ from the case with known origin,

35
00:02:53.371 --> 00:03:00.283
that we do not rely on a position of the
origin, so we just compute those features.

36
00:03:00.283 --> 00:03:04.983
And as we connect a chain
of five tracks and

37
00:03:04.983 --> 00:03:09.684
apply the same XGboost or random forest,

38
00:03:09.684 --> 00:03:15.056
we can get to the precision
that is comparable to

39
00:03:15.056 --> 00:03:21.550
the algorithm when we knew
the origin of the shower.

40
00:03:21.550 --> 00:03:25.230
So, it is actually fascinating
that those algorithm

41
00:03:25.230 --> 00:03:27.990
operate on the same level of accuracy.

42
00:03:27.990 --> 00:03:29.240
But in this case,

43
00:03:30.260 --> 00:03:35.640
we have much less information
about signal we are looking for.

44
00:03:37.750 --> 00:03:42.803
So, here is an illustration
how the density of tracks

45
00:03:42.803 --> 00:03:47.198
goes down with the threshold
of a classifier.

46
00:03:47.198 --> 00:03:55.580
So, we range from 100% of
the tracks to 10 or 5% of a signal.

47
00:03:56.820 --> 00:04:00.350
And you see how drastically reduces number

48
00:04:00.350 --> 00:04:03.530
of background tracks were
depicted by red color.

49
00:04:05.070 --> 00:04:10.010
So, going even further,
we might be wondering

50
00:04:10.010 --> 00:04:15.400
how can we find different
showers in the volume.

51
00:04:15.400 --> 00:04:19.440
So it is a realistic scenario for

52
00:04:19.440 --> 00:04:24.100
the case of showers, and
here we can apply clustering algorithm.

53
00:04:24.100 --> 00:04:30.260
The most trivial one of those
algorithms is K means algorithm.

54
00:04:30.260 --> 00:04:37.048
So, the basic idea that seems to
be behind this algorithm is that,

55
00:04:37.048 --> 00:04:42.879
for each point in the cluster
we can find a center nearby.

56
00:04:42.879 --> 00:04:45.929
And here you can see illustration, well,

57
00:04:45.929 --> 00:04:49.668
actually interactive if
you follow the link below.

58
00:04:49.668 --> 00:04:52.831
So, and
the algorithm is starting with given

59
00:04:52.831 --> 00:04:56.253
the number of clusters
that we are going to find.

60
00:04:56.253 --> 00:05:01.812
And then we randomly throw a bunch
of centers at the picture or

61
00:05:01.812 --> 00:05:05.630
select random centers among the points.

62
00:05:06.800 --> 00:05:09.545
Iteratively we update
the centers of the cluster, or

63
00:05:09.545 --> 00:05:13.410
update the color of every point.

64
00:05:13.410 --> 00:05:19.968
And eventually it converges to some
configuration, generally, it works.

65
00:05:19.968 --> 00:05:25.249
But in some cases,
it produces a little bit

66
00:05:25.249 --> 00:05:31.715
funny pictures like you see
at this image of a smile.

67
00:05:31.715 --> 00:05:35.990
That the K-means algorithm did not
capture a complicated dependency.

68
00:05:35.990 --> 00:05:40.610
For example it cannot build
a separate cluster for

69
00:05:40.610 --> 00:05:44.050
the circle shape and for eyes for example.

70
00:05:45.980 --> 00:05:49.480
So, another approach that we can
apply here is called density-based

71
00:05:49.480 --> 00:05:52.770
spatial clustering of
applications with noise, or

72
00:05:52.770 --> 00:05:58.320
DBSCAN for short,
it relies on two parameters.

73
00:05:58.320 --> 00:06:05.850
The first one is epsilon,
which is maximum distance to neighbors,

74
00:06:07.220 --> 00:06:11.840
and minimum number of points that
are required to form a cluster.

75
00:06:11.840 --> 00:06:16.560
It works the following way,
we pick a point and start with it,

76
00:06:16.560 --> 00:06:23.460
with a random point, and then find
all the neighbors that sits within

77
00:06:23.460 --> 00:06:29.598
the absolute distance from this point,
and iterate until we run out of points.

78
00:06:29.598 --> 00:06:35.460
So then we pick a new arbitrary point
that hasn't been marked by color yet,

79
00:06:35.460 --> 00:06:37.330
and repeat the process.

80
00:06:37.330 --> 00:06:42.252
If a point has fewer numbers
of neighbors than midpoints in

81
00:06:42.252 --> 00:06:46.850
this epsilon vicinity,
then we'd drop those points.

82
00:06:46.850 --> 00:06:50.810
So, and we repeat this process
until no points are left.

83
00:06:52.580 --> 00:06:56.860
And if we apply such an algorithm to

84
00:06:56.860 --> 00:07:02.900
a number of tracks that has been
preselected by previous algorithms,

85
00:07:02.900 --> 00:07:06.650
we can get a little bit
more interesting picture,

86
00:07:06.650 --> 00:07:12.320
with showers emerging from the volume.

87
00:07:12.320 --> 00:07:17.740
The thing is that it's not very realistic
because the distance metric that we

88
00:07:17.740 --> 00:07:24.820
used for this cluster algorithm that
when we computed this epsilon bowl for

89
00:07:24.820 --> 00:07:30.676
every given track, it just relies on
Euclidean distance, right?

90
00:07:30.676 --> 00:07:35.010
But we learned before
that we have to take care

91
00:07:35.010 --> 00:07:41.780
not only about relative positions, but
also relative angles between tracks.

92
00:07:41.780 --> 00:07:46.780
So, to improve the quality of the
algorithm we have to take into account, or

93
00:07:46.780 --> 00:07:47.920
add to the metric,

94
00:07:47.920 --> 00:07:53.580
additional term that corresponds
to the distance between angles.

95
00:07:53.580 --> 00:07:56.830
So, it's kind of improved
version of the metric.

96
00:07:58.120 --> 00:08:03.000
On illustration you see that
sometimes the closest basetracks,

97
00:08:03.000 --> 00:08:07.965
according to Euclidean metrics, are not
really belonging to the same shower,

98
00:08:07.965 --> 00:08:11.415
so you have to take angles into account.

99
00:08:11.415 --> 00:08:19.055
So, as a result the same volume of
brick might look much more realistic.

100
00:08:19.055 --> 00:08:25.614
So, showers are better visible here,
although there is still room for

101
00:08:25.614 --> 00:08:31.190
improvement because in this case
some plates are missing and

102
00:08:31.190 --> 00:08:38.096
one you have to take into account for
directional alignment of the tracks.

103
00:08:38.096 --> 00:08:43.858
So, further ideas for improvement
might include adding more advanced

104
00:08:43.858 --> 00:08:50.017
techniques like conditional random
fields or recurrent neural networks.

105
00:08:50.017 --> 00:08:54.644
But, I encourage you to explore when you

106
00:08:54.644 --> 00:08:58.872
will be completing your home tasks.

107
00:08:58.872 --> 00:09:04.260
And I hope that you will be
able to bypass the baseline

108
00:09:04.260 --> 00:09:08.429
quality in this task, in this problem.

109
00:09:08.429 --> 00:09:13.771
[MUSIC]